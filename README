Modeling Kernel Language (MKL) toolchain
Copyright (C) 2010-2011 David Broman

MKL toolchain is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MKL toolchain is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MKL toolchain.  If not, see <http://www.gnu.org/licenses/>.

MKL toolchain, version 1.0.1
-----------------------------------------------------
This project contains a simple interpreter for the 
modeling kernel language (MKL). For a detailed overview of the
MKL language, please see David Broman's PhD Thesis:
http://www.bromans.com/david/publ/thesis-2010-david-broman.pdf

If you have any comments or questions, please send an email to
david@bromans.com

INSTALLATION (Mac OS)
--------------------
To run the MKL interpreter on an UNIX-based system, 
do the following steps:

1. Install the SUNDIALS solver suite version 2.4.0 or later. 
   http://computation.llnl.gov/casc/sundials/
2. Install Macports (including X11 support)
   http://www.macports.org/
3. Install Objective Caml compiler, ocamlfind, and gnuplot via Macports
   >> sudo port install ocaml caml-findlib gnuplot
4. Unzip the MKL source code and compile the project using command
   >> build byte

EXAMPLES
--------
Under folder "library", a simple standard library for MKL is provided.
Two test files are also provided:
1. test-mechsys.mkl
   This test program generates Modelica flat code from a Mechatronic MKL
   model. Usage: mkl test-mechsys.mkl
2. test-lotkavolterra.mkl
   This test program shows a simple mathematical modeling that is simulated
   and plotted. Usage: mklplot test-lotkavolterra.mkl 

LICENSE
-------
All files in the MKL toolchain project, excepts for files in the folders 
"library/" and "other/" are under the GNU General Public Licence according 
to file COPYING. Files under folder "other/" have specific licenses given 
in each sub-folder. Files under folder "library/" are under the GNU Lesser
General Public License according to file "library/COPYING.LESSER".



REVISIONS
---------

Version 1.0.1
  - Added coercion semantics for int to reals, meaning that you can
    write 1.0 or 1 and that the type checker will insert conversions
    if necessary. Hence, we do not need to write 1. or 0. when using
    real constants.
  - Changed syntax for patterns 'var to ~var. 
  - Added new syntax for derivatives, e.g., der(x) can be written x' and
    der(der(y)) can be written y''
  - Fixed problem with init conditions. The function InitValues in
    elaboration.mkl must match pattern ~Init and not just Init.
  - Changed the syntax for polymorphic equality from == to <==>. Added 
    operators == and ==. meaning real and integer equality test respectively.
    The rationale is that == can now be used as part of a model.
  - Added two new keywords "begin" and "end", which have the same 
    functionality as parentheses.
  - Renamed initialization keyword from "Init" to "init". Also, the 
    init operator "<-" can be used instead of "init".
  - Renamed the "when" guard on patterns to use keyword "if". In this
    way, "when" can be used in the DSLs.
  - It is now possible to plot a probe that does not exist during the
    whole simulation, e.g., a probe that exists in a specific state.
  - A function can be called either by using space between paranthesis, e.g.
      foo p1 p2
    or to use paranthesis and a comma separated list (as in C or Java)
      foo(p1,p2)
    For the latter, it is important that it there are no white space
    between foo and the left paranhesis. In this case, this is
    translated into a curried call. If foo was supposed to take a tuple
    as argument, it can be called as follows (note the space)
      foo (p1,p2)

Version 1.0.0 - October 1, 2010
  - First version corresponding to David Broman's PhD Thesis.
  - Changed operators for Real and Int, so that e.g., -. and +. are
    for integer operations instead of Real. The rationale is that most
    expressions are written using Reals.
