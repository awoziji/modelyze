/*
* Wraps the mechanical2d library in order to construct the parts used by
* the modular robotic arm
* 
* When constructing the robotic arm, please do ONLY use the parts when
* constructing a model for the modular robotic arm as these "wrapper"
* inlcude adding the normal forces together for proper simulation of
* friction 
* 
*/

include mechanical2d	// Includes the parts
include modelyzeEOO


// Fixes the arm part to the ground
// Also needs the end flange which will experience 
// zero normal force
def Fix(flangeStart : Mechanical2D, flangeEnd : Mechanical2D) = {
  // Mass starts @zero
  def tmp, Fn : Real; 
  RefBranch(tmp,Fn,flangeEnd);
  Fn = 0.0;
  
  ArmFixed(flangeStart);
  
}

def BuildNormalForce(mAdd : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // For passing along the normal force in the system  
  def FnA, FnB, tmpA, tmpB : Real;
  RefBranch(tmpA,FnA,flangeA);
  RefBranch(-tmpB,FnB,flangeB);
  tmpA = tmpB;
  FnA = FnB + mAdd*9.81;  
}

def ReadNormalForce(flange : Mechanical2D, st : Signal) = {
  RefBranch(0.0,st,flange);
}

// A 20x20mm joint with specfic length
def Link20x20mm(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  def m = 0.5*L;
  def Lm = L/2.0;
  def I = m*L*L/12.0;	// Moment of inertia @ com
  
  BuildNormalForce(m,flangeA, flangeB);// Todo: the holes remove some of the inertia/mass
  ArmLink(L, Lm, I, m, flangeA, flangeB);
}

// A torque with no mass
def TorqueJoint(M : <Real>, df : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  BuildNormalForce(0.0,flangeA, flangeB);
  MasslessConstantTorqueJoint(M,df,flangeA,flangeB);  
}

// One joint object for each physical prototype

// DCX26L with gear ratio 150
def JointType1(u : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  
  def K = 0.0214; def R = 0.74+0.33; def L = 0.129e-3; def n = 150.0;
  def eta = 0.75; def df = 0.1;
  def mA = 0.7; def mB = 0.7; // Mass of the parts of the joint
  def JA = 0.05; // Moment of inertia around flangeA
  def JB = 0.249e-7 + 0.05; // Moment of inertia around flangeB
  def offset_A = 0.02; def offset_B = 0.055; // Lengths from end of link to middle of joint
  
  def Fn : Signal;
  def c1, c2, c3 : Real;
  
  BuildNormalForce((mA+mB),flangeA,flangeB);
  
  ReadNormalForce(flangeB,Fn);
  c1 = 0.0;	// Solver can't handle this :S
  c2 = 0.0;	// Solver can't handle this :S
  c3 = 0.01*(Fn+mB*9.81);
  
  //DCmotorJoint(u,K,R,L,n,eta,c1,c2,c3,JA,JB,(mA+mB),flangeA,flangeB);
  DCmotorJoint(u,K,R,L,n,eta,c1,c2,c3,JA,JB,mA+mB,offset_A,offset_B,flangeA,flangeB);
}
