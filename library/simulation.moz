/*
Modeling Kernel Language (Modelyze) library 
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.
*/

include MechatronicElaboration
include Differentiation
include IndexReduction

type StepVal = (Real,[Real])
type SimulationResult = ([String],[StepVal])

type Residual = Real -> {Real} -> {Real} -> [Real]




let makeResidual ukmap:UkMap -> model:Equations -> 
                 ctime:Real -> yy:{Real} -> yp:{Real} -> [Real] =
  let realExpr e:<> -> Real = 
    match e with
    | (lift f:(Real -> Real -> Real)) e1 e2 -> 
           f (realExpr e1) (realExpr e2)
    | (lift f:(Real -> Real)) e1 -> f  (realExpr e1) 
    | lift v:Real -> v
    | time -> ctime
    | der x -> (match x with 
                | sym:Signal -> Array.get yp (fst (Map.find x ukmap))
                | _ -> error "Derivatives only allowed on unknowns")
    | sym:Signal -> Array.get yy (fst(Map.find e ukmap))
    | _ -> error "Unsupported model construct" 
  in
  let traverseEq m:Equations -> acc:[Real] -> [Real] =
    match m with
    | e1 ; e2 -> traverseEq e2 (traverseEq e1 acc)
    | e1 = e2 -> (realExpr(e1) - realExpr(e2)) :: acc
    | _ -> acc
  in traverseEq model [] 


let makeNewResidual model:Equations -> ukmap:UkMap -> 
                 ctime:Real -> yy:{Real} -> yp:{Real} -> [Real] =
  let realExpr e:<> -> Real = 
    match e with
    | (lift f:(Real -> Real -> Real)) e1 e2 -> 
           f (realExpr e1) (realExpr e2)
    | (lift f:(Real -> Real)) e1 -> f  (realExpr e1) 
    | lift v:Real -> v
    | time -> ctime
    | der x -> (match x with 
                | sym:Signal -> Array.get yp (fst (Map.find x ukmap))
                | _ -> error "Derivatives only allowed on unknowns")
    | sym:Signal -> Array.get yy (fst(Map.find e ukmap))
    | _ -> error "Unsupported model construct" 
  in
  let traverseEq m:Equations -> acc:[Real] -> [Real] =
    match m with
    | e1 ; e2 -> traverseEq e2 (traverseEq e1 acc)
    | e1 = e2 -> (realExpr(e1) - realExpr(e2)) :: acc
    | _ -> acc
  in traverseEq model [] 


//Generate arrays of initial values
let makeInitValues model:Equations -> ukmap:UkMap -> ({Real},{Real}) =
  let initvalmap = initValues model in
  let size = Map.size ukmap in
  let yy = Array.make size 0. in
  let yp = Array.make size 0. in
  let setvals initvals:[(Signal,(Real,Bool))] -> {Real} =
    match initvals with
    | (u,(v,_))::xs -> 
        let _ = Array.set yy (fst (Map.find u ukmap)) v in setvals xs 
    | [] -> yy
  in (setvals  (Map.toList initvalmap), yp)



let makeStepVal currtime:Real -> yy:{Real} ->
                probes:[(String,[Signal])] -> ukmap:UkMap -> StepVal =
  let mkvals probes:[(String,[Signal])] -> [Real] =        
    match probes with
    | (s,u::us)::ss -> (Array.get yy (fst(Map.find u ukmap)))::
                        (mkvals ((s,us)::ss))
    | (s,[])::ss -> mkvals ss 
    | [] -> []
  in (currtime,mkvals probes)
  
let makeProbeNames probes:[(String,[Signal])] -> n:Int -> [String] =        
  match probes with
  | (s,u::us)::ss -> 
    let s2 = s ++ (if n >. 1d then "_" ++ int2string(n) else "") in
    s2::(makeProbeNames ((s,us)::ss) (n +. 1d))
  | (s,[])::ss -> makeProbeNames ss 1d
  | [] -> []

let initConditionCorrection ukmap:UkMap -> {Real} =
  let id = Array.make (Map.size ukmap) 0 in
  let worker uklist:[(Signal,(Int,Bool))] -> {Real} =
    match uklist with
    | (u,(i,true))::us -> let _ = Array.set id i 1.0 in worker us
    | _::us -> worker us
    | [] -> id
  in worker (Map.toList ukmap)

let revResult lst:[StepVal] -> acc:[StepVal] -> [StepVal] =
  match lst with
  | x::xs -> revResult xs (x::acc)
  | [] -> acc 

let simulate model:Equations -> steptime:Real -> endtime:Real -> 
             SimulationResult =
  let (model2,probes) = elaborate model in
  let probelist = Map.toList probes in
  let (model3,_) = elaborateDerivatives model2 (Map.empty) in
  let (model4,_) = indexReducationPantelides model3 (Map.empty) in
  let ukmap = makeUkMap model4 in
  let residual = specialize (makeResidual ukmap) model4 in
  let (yy,yp) = makeInitValues model4 ukmap in
  let id = initConditionCorrection ukmap in
  let state = DAESolver.make yy yp id residual in
  let simloop currtime:Real -> acc:[StepVal] -> [StepVal] = 
    if currtime >= endtime then acc
    else
      let newtime = DAESolver.step steptime state in 
      let stepval = makeStepVal newtime yy probelist ukmap in
      if newtime == 0. then acc
      else simloop newtime (stepval::acc)
  in
    (makeProbeNames probelist 1d,revResult (simloop 0 []) []) 

let pprintSimulation res:SimulationResult -> String =
  let (names,stepvals) = res in  
  let psteps step:[StepVal] -> first:Bool -> String =
    match step with
    | (t,x::xs)::xxs if first ->        
        real2string(t) ++ "\t" ++ psteps((t,x::xs)::xxs,false)
    | (t,x::xs)::xxs -> 
        real2string(x) ++ "\t" ++ psteps((t,xs)::xxs,false)
    | (t,[])::xxs -> "\n" ++ psteps(xxs,true)
    | [] -> ""
  in psteps(stepvals,true)
 
let printsim model:Equations -> steptime:Real -> endtime:Real -> () =
      print (pprintSimulation (simulate model steptime endtime))





