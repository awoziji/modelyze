/*
Modeling Kernel Language (Modelyze) library 
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.
*/

// Notes
// - I did not change elaborate functions or differentation functions.
// - Needed to update the simulation loop to include the discrete changes.


include Modeling
type Node = <>
type Unknown = <>
type Branches = <>
type NodeMap = (Node => Unknown)
type NodeMapList = [(Node,Unknown)]
type BranchSet = (Set Branches)
type BranchList = [Branches]
type ExprMap = (Node => Expr)
type ExprList = [(Node, Expr)]
type ProbeMap =  (String => [Signal])


type SubExprMap = (<> => Signal)
type SubExprList = [(<>,Signal)]


let elaborateConnections model:Equations -> 
                         Equations =
  let addNode node:Node -> nodemap:NodeMap -> NodeMap =
    if Map.mem node nodemap then nodemap
    else let u:<Real> in Map.add node u nodemap
  in

  let sumexpr branches:BranchSet -> ExprMap = 
    let worker branches:BranchList -> emap:ExprMap -> ExprMap =
      match branches with
      | (Branch i v p n)::bs ->  
          let emap1 = if Map.mem p emap 
                      then Map.add p ((Map.find p emap) + i) emap
                      else Map.add p i emap in
          let emap2 = if Map.mem n emap1 
                      then Map.add n ((Map.find n emap1) - i) emap1
                      else Map.add n (-i) emap1 in
          worker bs emap2
      | (RefBranch i v p)::bs -> 
          let emap1 = if Map.mem p emap 
                      then Map.add p ((Map.find p emap) + i) emap
                      else Map.add p i emap in
          worker bs emap1
      | [] -> emap
    in worker (Set.toList branches) (Map.empty)
  in

  let sumzero m:Equations -> branches:BranchSet -> Equations =
    let worker elist:ExprList -> Equations =
      match elist with
      | (_,e)::es -> e = 0.; worker es
      | [] -> m
    in worker (Map.toList (sumexpr branches))
  in

  let potentials model:Equations -> (Equations,BranchSet) =
    let worker m:Equations -> nodemap:NodeMap -> 
                branchset:BranchSet -> (<>,NodeMap,BranchSet) =
      match m with
      | Branch i v p n ->
        let nodemap2 = addNode n (addNode p nodemap) in
        let eq = (v = (Map.find p nodemap2) - 
                 (Map.find n nodemap2)) in
        (eq,nodemap2,Set.add m branchset)
      | RefBranch i v p ->
        let nodemap2 = addNode p nodemap in
        let eq = (v = (Map.find p nodemap2)) in
        (eq,nodemap2,Set.add m branchset)
      | e1 ; e2 -> 
         let (e1b,nodemap1,branchset1) = 
               worker e1 nodemap branchset in
         let (e2b,nodemap2,branchset2) = 
               worker e2 nodemap1 branchset1 in
         (e1b ; e2b, nodemap2, branchset2)
      | _ ->  (m,nodemap,branchset) 
    in 
      let (model,_,branchset) = 
        worker model (Map.empty) (Set.empty) 
      in (model,branchset)
  in 
     let (model2,branchset2) = potentials model in
     sumzero model2 branchset2

let addProbe s:String -> u:Signal -> ps:ProbeMap =
    if Map.mem s ps then Map.add s (u::(Map.find s ps)) ps
    else Map.add s [u] ps

let elaborateProbes model:Equations -> (<Equations>,ProbeMap) =
  let elab e:<> -> ps:ProbeMap -> (<>,ProbeMap) = 
    match e with
    | ~probe (lift s:String) -> let u:Signal in (u,addProbe s u ps)
    | e1 e2 -> 
       let (e1b,ps1) = elab e1 ps in
       let (e2b,ps2) = elab e2 ps1 in
       (e1b e2b,ps2)
    | _ -> (e,ps)
  in elab model (Map.empty)

 



