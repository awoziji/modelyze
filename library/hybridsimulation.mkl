/*
Modeling Kernel Language (MKL) library 
Copyright (C) 2010 David Broman

MKL library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MKL library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with MKL library.  If not, see <http://www.gnu.org/licenses/>.
*/

include HybridModeling
include Mechanical
include Electrical
include Elaboration
include Differentiation

let isMechatronicBranch b:Node = 
  match b with
  | ~ElectricalBranch -> true
  | ~RotationalBranch -> true
  | _ -> false

let isMechatronicRefBranch b:Node = 
  match b with
  | ~ElectricalRefBranch -> true
  | ~RotationalRefBranch -> true
  | _ -> false

let ROOT_TOL = 1e-10

type StepVal = (Real,[Real])
type SimulationResult = ([String],[StepVal])
type InitValMap = (<Real> => <Real>)
type ZeroCrossing = <Real>
type Transitions = [(State,State,Expr,Expr)]

//Statw path of states through the hierarchy of statecharts
type StatePath = [State]

let lastEvent = {-1.0}

//Extract the current hierarical state of equations as well as 
//all possible transitions.
let extractHState model:Equations -> freshState:Bool ->
    prePath:StatePath -> currPath:StatePath -> (Equations,Transitions) =
  let extract m:Equations -> acc:Transitions -> fresh:Bool ->
    pre:StatePath -> curr:StatePath -> cstate:State -> (<>,Transitions) =
    match m with
    | ~statechart s e -> 
      (match (pre,curr) with
       | (_,[]) -> extract e acc true [] [] s
       | (p::ps,c::cs) -> if p == c then extract e acc false ps cs p
                          else extract e acc true ps cs c)
    | ~state s e -> if s == cstate 
                      then extract e acc fresh pre curr s 
                      else (NoEq,acc)
    | ~transition nstate guard initexp -> 
          (NoEq,(cstate,nstate,guard,initexp)::acc)
    | ~Init x e -> if fresh then (Init x e,acc) else (NoEq,acc)
    | e1 e2 ->  
         let (eqs1,acc1) = extract e1 acc fresh pre curr cstate in
         let (eqs2,acc2) = extract e2 acc1 fresh pre curr cstate in
         (eqs1 eqs2,acc2)
    | e -> (e,acc)
  in  
    extract model [] freshState prePath currPath topstate

type Residual = Real -> {Real} -> {Real} -> [Real]

let initValues eqs:Equations -> InitValMap =
  let get eqs:Equations -> acc:InitValMap -> InitValMap =
    match eqs with
    | e1 ; e2 -> get e2 (get e1 acc)
    | ~Init x v -> Map.add x v acc
    | _ -> acc
  in get eqs (Map.empty)


let makePreValMap yy:{Real} -> yp:{Real} -> ukmap:UkMap -> 
                  (InitValMap,InitValMap) =
  let worker lst:UkList -> yymap:InitValMap -> ypmap:InitValMap -> 
             (InitValMap,InitValMap) =
    match lst with
    | (u,(i,_))::xs ->
         worker xs (Map.add u (val (Array.get yy i)) yymap)
                   (Map.add u (val (Array.get yp i)) ypmap) 
    | [] -> (yymap,ypmap)
  in
    worker (Map.toList ukmap) (Map.empty) (Map.empty)


let eval expr:Expr -> yyfun:(Signal->Signal) -> ypfun:(Signal->Signal) ->
         ctime:Real -> Real =
  let worker e:<> -> Real = 
    match e with
    | (val f:(Real -> Real -> Real)) e1 e2 -> 
           f (worker e1) (worker e2)
    | (val f:(Real -> Real)) e1 -> f  (worker e1) 
    | val v:Real -> v
    | ~time -> ctime
    | ~der x -> (match x with 
                | uk:Signal -> worker (ypfun x)  
                | _ -> error "Derivatives only allowed on unknowns")
    | uk:Signal -> worker (yyfun e)
    | _ -> let _ = dpa e in error "Unsupported model construct" 
  in
    worker expr 

let evalFromMap expr:Expr -> valmap:InitValMap -> ctime:Real -> Real =
  let yyfun s:Signal -> Signal = Map.find s valmap in
  let ypfun s:Signal -> Signal = Map.find (der s) valmap in  
  eval expr yyfun ypfun ctime 

let evalFromArray expr:Expr -> yy:{Real} -> yp:{Real} -> 
      ukmap:UkMap -> ctime:Real -> Real =
  let yyfun s:Signal -> Signal = 
     val (Array.get yy (fst(Map.find s ukmap))) in
  let ypfun s:Signal -> Signal = 
     val (Array.get yp (fst (Map.find s ukmap))) in
  eval expr yyfun ypfun ctime 

let makeResidual model:Equations -> ukmap:UkMap -> 
                 ctime:Real -> yy:{Real} -> yp:{Real} -> [Real] =
  let realExpr expr:Expr -> Real = evalFromArray expr yy yp ukmap ctime in
  let traverseEq m:Equations -> acc:[Real] -> [Real] =
    match m with
    | e1 ; e2 -> traverseEq e2 (traverseEq e1 acc)
    | e1 = e2 -> (realExpr e1 - realExpr e2) :: acc
    | _ -> acc
  in traverseEq model [] 
   
let makeRootFun trans:Transitions -> ukmap:UkMap -> initVal:InitValMap ->
                ctime:Real -> yy:{Real} -> yp:{Real} -> [Real] = 
//  let travtrans trans:Transitions -> [Real] = 
//    match trans with
//    (s1,s2,g,i)::ts -> 

   [if (ctime >= 2.0) && (Array.get lastEvent 0) < 2.0 then 0. else 1.0]   
/*  let eval = evaluate false ukmap yy yp (Map.empty) initVal ctime in
  let make zcList:[ZeroCrossing] -> acc:[Real] -> [Real] =
    match zcList with
    | exp::ls -> 
          make ls ((castReal(eval exp))::acc)
    | [] -> acc
  in make zcList []
*/

let eventFound state:DAESolver -> ctime:Real -> Bool =
  let roots = DAESolver.roots state in
  if (Array.length roots) !=. 0 
    then let _ = Array.set lastEvent 0 ctime in true 
    else false
  

//Generate arrays of initial values
let makeInitStateArrays initvals:InitValMap -> 
                        yymap:InitValMap -> ypmap:InitValMap -> 
                        ctime:Real -> ukmap:UkMap -> ({Real},{Real}) =
  let size = Map.size ukmap in
  let yy = Array.make size 0. in
  let yp = Array.make size 0. in
  let setvals initvals:[(Signal,Signal)] -> arr:{Real} -> () =
    match initvals with
    | (u,e)::xs -> 
        let v = evalFromMap e yymap ctime in
        let _ = if Map.mem u ukmap 
                  then Array.set arr (fst (Map.find u ukmap)) v  
                  else ()
        in setvals xs arr
    | [] -> ()
  in 
    let _ = setvals (Map.toList yymap) yy in
    let _ = setvals (Map.toList initvals) yy in
    let _ = setvals (Map.toList ypmap) yp in
    (yy, yp)


let makeStepVal currtime:Real -> yy:{Real} ->
                probes:[(String,[Signal])] -> ukmap:UkMap -> StepVal =
  let mkvals probes:[(String,[Signal])] -> [Real] =        
    match probes with
    | (s,u::us)::ss ->  (Array.get yy (fst(Map.find u ukmap)))::
                        (mkvals ((s,us)::ss))
    | (s,[])::ss -> mkvals ss 
    | [] -> []
  in (currtime,mkvals probes)
  
let makeProbeNames probes:[(String,[Signal])] -> n:Int -> [String] =        
  match probes with
  | (s,u::us)::ss -> 
    let s2 = s ++ (if n >. 1 then "_" ++ int2string n else "") in
    s2::(makeProbeNames ((s,us)::ss) (n +. 1))
  | (s,[])::ss -> makeProbeNames ss 1
  | [] -> []

let initConditionCorrection ukmap:UkMap -> {Real} =
  let id = Array.make (Map.size ukmap) 0. in
  let worker uklist:[(Signal,(Int,Bool))] -> {Real} =
    match uklist with
    | (u,(i,true))::us -> let _ = Array.set id i 1.0 in worker us
    | _::us -> worker us
    | [] -> id
  in worker (Map.toList ukmap)

let revResult lst:[StepVal] -> acc:[StepVal] -> [StepVal] =
  match lst with
  | x::xs -> revResult xs (x::acc)
  | [] -> acc 

// The main simulation function. Performs hybrid simulation using
// hierarical state machines and differential-algebraic equations
let simulate model:Equations -> steptime:Real -> endtime:Real -> 
             SimulationResult =
  // Extract probes
  let (model1,probes) = elaborateProbes model in
  let probelist = Map.toList probes in

  // **** Start of discrete-time loop. ****
  //    Iterate for each state change
  let dtloop currtime:Real -> acc:[StepVal] -> model1:Equations -> 
             yymap:InitValMap -> ypmap:InitValMap ->
             olddmap:DerivMap -> prePath:StatePath -> currPath:StatePath ->
             [StepVal] = 
    // Extract all equations and correct inits for a partiuclar state path. 
    let (modelNoState,transitions) = extractHState model1 (currtime == 0.)
                                        prePath currPath in
    // Performe connection elaboration
    let model2 = (elaborateConnections isMechatronicBranch 
                  isMechatronicRefBranch modelNoState) in
    // Elaborate derivatives, e.g., get rid of higher-order deriviatives.
    let (model3,newdmap) = elaborateDerivatives model2 olddmap in

    // Create a map of unknowns to unique integer values
    let ukmap = makeUkMap model3 in
    
    // Create the DAE residual 
    let residual = makeResidual model3 ukmap in

    // Create a map with all initial values for the current state
    let initvalmap = initValues model3 in
    let (yy,yp) = makeInitStateArrays initvalmap yymap ypmap currtime ukmap in

    // Auto correct initial conditions of the DAE
    let id = initConditionCorrection ukmap in

    // Create the root function for detecting zero crossings
    let rootfun = makeRootFun transitions ukmap initvalmap in  

    // Create the simulation instance for continuous-time simulation using IDA
    let state = DAESolver.makehybrid currtime yy yp id residual rootfun in
    
    //Return the values for the pre value (time 0 the first time)
    let firststepval = makeStepVal currtime yy probelist ukmap in

    // **** Start of continuous-time loop *****
    let ctloop currtime:Real -> acc:[StepVal] -> ([StepVal],Real) = 
      if currtime > endtime 
        then (acc,currtime)
        else
          let newtime = DAESolver.step steptime state in 
          let stepval = makeStepVal newtime yy probelist ukmap in
          if newtime == 0. || eventFound state newtime
            then (stepval::acc,newtime)
            else ctloop (newtime + steptime) (stepval::acc)
    in
      // Post processing after continuous-time simulation 
      let (acc2,newtime) = ctloop currtime (firststepval::acc) in
      // Close the continuous-time DAE solver instance.
      let _ = DAESolver.close state in

      // Update and generate a new state path
      let newPath = currPath in //TODO

      // Perform another round of CT simulation?
      if newtime > endtime then acc2  
      else 
        let (yymap,ypmap) = makePreValMap yy yp ukmap in
        dtloop newtime acc2 model1 yymap ypmap newdmap currPath newPath
  in
    // Initiate the hybrid simulation loop (CT + DT)
    let result = revResult (dtloop 0. [] model1 
                 (Map.empty) (Map.empty) (Map.empty) [] []) [] in
    (makeProbeNames probelist 1,result) 


let pprintSimulation res:SimulationResult -> String =
  let (names,stepvals) = res in  
  let psteps step:[StepVal] -> first:Bool -> String =
    match step with
    | (t,x::xs)::xxs when first ->        
        real2string t ++ "\t" ++ psteps ((t,x::xs)::xxs) false
    | (t,x::xs)::xxs -> 
        real2string x ++ "\t" ++ psteps ((t,xs)::xxs) false
    | (t,[])::xxs -> "\n" ++ psteps xxs true
    | [] -> ""
  in psteps stepvals true
 
let printsim model:Equations -> steptime:Real -> endtime:Real -> () =
      print (pprintSimulation (simulate model steptime endtime))





