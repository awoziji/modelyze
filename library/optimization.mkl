
include Modeling

type KeywordInterval
let interval : KeywordInterval

type KeywordIntegral
let integral : KeywordIntegral

let minimize : <KeywordIntegral -> Real -> KeywordInterval -> 
                Real -> Real -> Equations>
let input : <Real -> Equations>

type VarSet = Set Signal
type VarMap = (Signal => Signal)
type ModelVars = (VarSet,VarSet,VarSet)
type MeshVars  = (VarMap,VarMap,VarMap)
type VarNameMap = (Signal => String)

// There may be something built-in to do this...
def getModelSizes(modelVars:ModelVars) : (Int, Int, Int) = {
    def setSize(varLst:[Signal], n:Int) : Int = {
        match varLst with
        | v::vs -> {
            setSize(vs, n+.1)
            }
        | [] -> n        
    };	
    def (x,y,u) = modelVars;
    def xList = (Set.toList x);
    def yList = (Set.toList y);
    def uList = (Set.toList u);
    def nx = setSize(xList,0);
    def ny = setSize(yList,0);
    def nu = setSize(uList,0);
    (nx,ny,nu)
}

// TODO:
// 1. Introduce type OCP: equations, initial conditions, L-function (cost), startTime, finalTime
//  - getOCP(equations : Equations)
// 2. Introduce type NLP: meshVars, constraints, cost
//  - getNLP(ocp : OCP)
// 3. A function codeGen(nlp: NLP)
def genMeshVarNameMap(meshVars:[MeshVars]) : VarNameMap = {
    def genName(vPrefix:String, mNbr:Int, vNbr:Int) : String = {
        vPrefix ++ "_" ++ int2string(mNbr) ++ "_" ++ int2string(vNbr)
    };
    def iterMeshVars(meshPointVars:MeshVars, mNbr:Int, nameMap:VarNameMap) : VarNameMap = {
        def genNames(varList:[(Signal,Signal)], vPrefix:String, vNbr:Int, nameMap:VarNameMap) : VarNameMap = {
            match varList with
            | v::vs -> {
                def (_,vv) = v;
                def n = genName(vPrefix, mNbr, vNbr);
                genNames(vs, vPrefix, vNbr+.1, (Map.add vv n nameMap))
                }
            | [] -> nameMap        
        };
	def (xMap, yMap, uMap) = meshPointVars;
        def xList = (Map.toList xMap);
        def nameMap_tmp1 = genNames(xList,"x",1,nameMap);
        def yList = (Map.toList yMap);
        def nameMap_tmp2 = genNames(yList,"y",1,nameMap_tmp1);
        def uList = (Map.toList uMap);
        genNames(uList,"u",1,nameMap_tmp2)
    };
    def iterMeshPoints(meshPointList:[MeshVars], mNbr:Int, nameMap:VarNameMap) : VarNameMap = {
        match meshPointList with
        | mv::mvs -> iterMeshPoints(mvs, mNbr+.1, iterMeshVars(mv, mNbr, nameMap)) 
        | [] -> nameMap        
    };
    iterMeshPoints(meshVars, 1, Map.empty)
}

// The input argument here is actually not needed, not sure how to
// define a function witout arguments.
def pprintPythonCasadiHeader(varNameMap:VarNameMap) : String = {
   "import casadi as C\n" ++
   "import numpy as N\n" ++
   "import matplotlib.pyplot as plt\n\n"
}

def pprintPythonCasadiIpoptSolve(n_e:Int, start_time:Real, final_time:Real, nx:Int, ny:Int, nu:Int) : String = {
    "# Create the NLP cost function\n"++
    "cost_func = C.SXFunction([z],[cost])\n"++
    "cost_func.init()\n"++
    "# Create the NLP constraints\n"++
    "constr_func = C.SXFunction([z],[constr])\n"++
    "constr_func.init()\n"++
    "# Create the IPOPT solver object\n"++
    "solver = C.IpoptSolver(cost_func,constr_func)\n"++
    "solver.init()\n"++
    "# Set initial guess and variable bounds\n"++
    "z_init = N.zeros(len(z))\n"++
    "z_ub = 1e20*N.ones(len(z))\n"++
    "z_lb = -1e20*N.ones(len(z))\n"++
    "solver.setInput(z_init,C.NLP_X_INIT)\n"++
    "solver.setInput(z_ub,C.NLP_UBX)\n"++
    "solver.setInput(z_lb,C.NLP_LBX)\n"++
    "# Set constratint bounds (equality constratins)\n"++
    "constr_ub = N.zeros(len(constr))\n"++
    "constr_lb = N.zeros(len(constr))\n"++           
    "solver.setInput(constr_ub,C.NLP_UBG)\n"++
    "solver.setInput(constr_lb,C.NLP_LBG)\n"++
    "# Solve the problem\n"++
    "solver.solve()\n"++
    "# Extract the solution\n"++
    "z_opt = solver.output(C.NLP_X_OPT)\n"++
    "n_x = " ++ int2string(nx) ++ "\n"++
    "n_w = " ++ int2string(ny) ++ "\n"++
    "n_u = " ++ int2string(nu) ++ "\n"++
    "n_e = " ++ int2string(n_e) ++ "\n"++
    "start_time = " ++ real2string(start_time)  ++ "\n"++
    "final_time = " ++ real2string(final_time)  ++ "\n"++
    "time = N.arange(start_time,final_time,(final_time-start_time)/n_e)\n"++
    "xx = N.zeros((n_e,n_x))\n"++
    "ww = N.zeros((n_e,n_w))\n"++
    "uu = N.zeros((n_e,n_u))\n"++
    "for i in range(n_x):\n"++
    "    xx[:,i] = N.array(z_opt[n_u + n_w + i::(n_x + n_u + n_w)])[:,0]\n"++
    "for i in range(n_w):\n"++
    "    ww[:,i] = N.array(z_opt[n_u + i::(n_x + n_u + n_w)])[:,0]\n"++
    "for i in range(n_u):\n"++
    "    uu[:,i] = N.array(z_opt[i::(n_x + n_u + n_w)])[:,0]\n"++
    "if n_x>0:\n"++
    "    plt.figure(1)\n"++
    "    plt.plot(time,xx)\n"++
    "    plt.grid(True)\n"++
    "    plt.show()\n"++
    "if n_w>0:\n"++
    "    plt.figure(2)\n"++
    "    plt.plot(time,ww)\n"++
    "    plt.grid(True)\n"++
    "    plt.show()\n"++
    "if n_u>0:\n"++
    "    plt.figure(3)\n"++
    "    plt.plot(time,uu)\n"++
    "    plt.grid(True)\n"++
    "    plt.show()\n"
}

def pprintPythonCasadiDecls(varNameMap:VarNameMap) : String = {
    def pprintVar(name:String) : String = {
        name ++ " = " ++ "C.SX(\"" ++ name ++ "\")\nz.append(" ++ name ++ ")"
    };
    def iterVars(varList:[(Signal,String)], acc:String) : String = {
        match varList with
        | v::vs -> {
            def (_,name) = v; 
            iterVars(vs, (acc ++ pprintVar(name) ++ "\n"))
        }
        | [] -> acc
    };
    def varNameList = (Map.toList varNameMap);	
    iterVars(varNameList,"z = []\n")
}

def pprintPythonCasadiExpr(expr:Expr, varNameMap:VarNameMap) : String = {
    def printExpr(expr:Expr) : String = {
    match expr with 
    | e1 + e2 -> "(" ++ printExpr(e1) ++ " + " ++ printExpr(e2) ++ ")"
    | e1 - e2 -> "(" ++ printExpr(e1) ++ " - " ++ printExpr(e2) ++ ")"
    | e1 * e2 -> printExpr(e1) ++ " * " ++ printExpr(e2) 
    | e1 / e2 -> printExpr(e1) ++ " / " ++ printExpr(e2) 
    | -e ->     "(-" ++ printExpr(e) ++ ")" 
    | e1^e2 -> "(" ++ printExpr(e1) ++ ")" ++ " ^ " ++ "(" ++ printExpr(e2) ++ ")"
    | ~der e ->   "der(" ++ printExpr(e) ++ ")"
    | ~sin e ->   "sin(" ++ printExpr(e) ++ ")"
    | ~cos e ->   "cos(" ++ printExpr(e) ++ ")"
    | ~tan e ->   "tan(" ++ printExpr(e) ++ ")"
    | ~asin e ->  "asin(" ++ printExpr(e) ++ ")"
    | ~acos e ->  "acos(" ++ printExpr(e) ++ ")"
    | ~atan e ->  "atan(" ++ printExpr(e) ++ ")"
    | ~sinh e ->  "sinh(" ++ printExpr(e) ++ ")"
    | ~cosh e ->  "cosh(" ++ printExpr(e) ++ ")"
    | ~tanh e ->  "tanh(" ++ printExpr(e) ++ ")"
    | ~sqrt e ->  "sqrt(" ++ printExpr(e) ++ ")"
    | ~exp e ->   "exp(" ++ printExpr(e) ++ ")"
    | ~log e ->   "log(" ++ printExpr(e) ++ ")"
    | ~log10 e -> "log10(" ++ printExpr(e) ++ ")"
    | ~time -> "time"
    | sym:<Real> -> (Map.find expr varNameMap)
    | val r:Real -> real2string(r)
    };
    printExpr(expr)
}

def pprintPythonCasadiConstrs(equations:Equations, varNameMap:VarNameMap) : String = {
    def printEquations(equations:Equations, constrs:String) : String = {
	match equations with
        | eq1 ; eq2 -> printEquations(eq1, constrs) ++ printEquations(eq2,constrs)
        | left = right -> "constr.append((" ++ pprintPythonCasadiExpr(left,varNameMap) ++ ") - (" ++ pprintPythonCasadiExpr(right, varNameMap) ++ "))\n"
        | _ -> ""
    };
    "constr = []\n" ++ printEquations(equations, "")
}

def pprintPythonCasadiCost(cost:Expr, varNameMap:VarNameMap) : String = {
    "cost = " ++ pprintPythonCasadiExpr(cost, varNameMap) ++ "\n"
}

def genInitMap(model:Equations) : VarMap = {
    def gen(m:Expr,acc:VarMap) : VarMap = {
        match m with
        | ~init (x=v) -> Map.add x v acc 
        | e1 e2 -> gen(e2,gen(e1,acc))
        | _ -> acc
    };
    gen(model,Map.empty)
}

def generateMeshVars(daeVars:ModelVars,n_e:Int) : [MeshVars] = {
    def genvar(varlst:[Signal],acc:VarMap) : VarMap = {
        match varlst with
        | v::vs -> {
             def m:Signal; 
             genvar(vs,Map.add v m acc)
          }
        | [] -> acc
    };
    def gen(vars:VarSet) : VarMap = genvar(Set.toList vars,Map.empty);
    def (x,y,u) = daeVars;
    def genmesh(n:Int) : [MeshVars] = {
        if n ==. 0 then [] 
        else (gen(x),gen(y),gen(u))::genmesh(n-.1) 
    };            
    genmesh(n_e)
}

def genNLPCost(cost:Expr, h:Real, meshVars:[MeshVars]) : Expr = {
    def substituteVars(exp:Expr, meshVars:MeshVars) : Expr ={
        def (xMap,yMap,uMap) = meshVars;
        match exp with
        | sym:Signal if Map.mem exp xMap -> Map.find exp xMap
        | sym:Signal if Map.mem exp yMap -> Map.find exp yMap
        | sym:Signal if Map.mem exp uMap -> Map.find exp uMap
        | e1 e2 -> {
            def e1b = substituteVars(e1, meshVars);
            def e2b = substituteVars(e2, meshVars);
            e1b e2b
          }
        | e -> e 
    };
    def genCostFunction(meshVarList:[MeshVars], cNLP:Expr) : Expr = {
        match meshVarList with
        | mv::mvs -> genCostFunction(mvs, cNLP + substituteVars(cost, mv)*h)
        | [] -> cNLP
    };
    genCostFunction(meshVars, val 0.0)
}

def genNLPConstraint(model:Equations, x0:VarMap, h:Real, meshVars:[MeshVars]) :
    Equations = {
    def substituteVars(model:Expr, prevX:VarMap, meshVars:MeshVars) : Expr = {
        def (xMap,yMap,uMap) = meshVars;
        match model with
        | ~der x -> ((Map.find x xMap) - (Map.find x prevX))/h
        | sym:Signal if Map.mem model xMap -> Map.find model xMap
        | sym:Signal if Map.mem model yMap -> Map.find model yMap
        | sym:Signal if Map.mem model uMap -> Map.find model uMap
        | e1 e2 -> {
            def e1b = substituteVars(e1, prevX, meshVars);
            def e2b = substituteVars(e2, prevX, meshVars);
            e1b e2b
          }
        | e -> e 
    };
    def genMeshPointConstraints(prevX:VarMap, meshVarList:[MeshVars], 
                                acc:Equations) : Equations = {
       match meshVarList with
       | mv::mvs -> {
           def (xMap,_,_) = mv;
           def meshPointConstr = substituteVars(model, prevX, mv);
           genMeshPointConstraints(xMap, mvs, acc ; meshPointConstr)
         }
       | [] -> acc
    };
    genMeshPointConstraints(x0, meshVars, NoEqn)
}

//Extract all types of variabels from a model. The return tuple
//is (x,y,u), where x is the state derivatives, y the algebraic variables
//and u the  input (control) signals
def extractVariables(model:Equations) : ModelVars = {
    def trav(e:Expr,acc:ModelVars) : ModelVars = {
        match (e,acc) with
        | (~der (sym:Signal),(X,Y,U)) -> 
             (match e with |~der x -> 
                if Set.mem x U then (X,Y,U) 
                else (Set.add x X,Set.remove x Y,U))
        | (~input (sym:Signal),(X,Y,U)) -> 
             (match e with |~input u -> 
               (Set.remove u X,Set.remove u Y,Set.add u U))
        | (sym:Signal,(X,Y,U)) -> 
             if (Set.mem e X) || (Set.mem e U) then (X,Y,U)
             else (X,Set.add e Y,U)
        | (e1 e2,_) -> trav e2 (trav e1 acc) 
        | _ -> acc
    };
    trav(model,(Set.empty,Set.empty,Set.empty))
}
  

//Traverse the model and extract the optimixation problem. In the 
//return tuple, the first parameter is the cost function, the
//second parameter t_0 and the third parameter t_f
def getOptProblem(model:Equations) : (Expr,Real,Real) = {
    def trav(e:Equations,rest:[Expr]) : (Expr,Real,Real) = {
        match (e,rest) with
        | (~minimize ~integral L ~interval (val start:Real) (val stop:Real),_) 
            -> (L,start,stop)
        | (e1;e2,_) -> trav(e1,e2::rest)
        | (_,e::es) -> trav(e,es)
        | (_,[]) -> error "No optimization problem found"
    };
    trav(model,[])
}




