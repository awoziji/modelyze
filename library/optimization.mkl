
include Modeling

type KeywordInterval
let interval : <KeywordInterval>

type KeywordIntegral
let integral : <KeywordIntegral>

let minimize : <KeywordIntegral -> Real -> KeywordInterval -> 
                Real -> Real -> Eqs>
let input : <Real -> Eqs>

type VarSet = Set Signal
type VarMap = (VarSet => VarSet)
type ModelVars = (VarSet,VarSet,VarSet)
type MeshVars  = (VarMap,VarMap,VarMap)

def generateMeshVars(mVars:ModelVars,n_e:Int) : [MeshVars] = {
   []
}




//Extract all types of variabels from a model. The return tuple
//is (x,y,u), where x is the state derivatives, y the algebraic variables
//and u the  input (control) signals
def extractVariables(model:Equations) : ModelVars = {
    def trav(e:Expr,acc:ModelVars) : ModelVars = {
        match (e,acc) with
        | (~der (uk:Signal),(X,Y,U)) -> 
             (match e with |~der x -> 
                if Set.mem x U then (X,Y,U) 
                else (Set.add x X,Set.remove x Y,U))
        | (~input (uk:Signal),(X,Y,U)) -> 
             (match e with |~input u -> 
               (Set.remove u X,Set.remove u Y,Set.add u U))
        | (uk:Signal,(X,Y,U)) -> 
             if (Set.mem e X) || (Set.mem e U) then (X,Y,U)
             else (X,Set.add e Y,U)
        | (e1 e2,_) -> trav e2 (trav e1 acc) 
        | _ -> acc
    } in
    trav(model,(Set.empty,Set.empty,Set.empty))
}
  
//Traverse the model and extract the optimixation problem. In the 
//return tuple, the first parameter is the cost function, the
//second parameter t_0 and the third parameter t_f
def getOptProblem(model:Equations) : (Expr,Real,Real) = {
    def trav(e:Equations,rest:[Expr]) : (Expr,Real,Real) = {
        match (e,rest) with
        | (~minimize ~integral L ~interval (val start:Real) (val stop:Real),_) 
            -> (L,start,stop)
        | (e1;e2,_) -> trav(e1,e2::rest)
        | (_,e::es) -> trav(e,es)
        | (_,[]) -> error "No optimization problem found"
    } in
    trav(model,[]) 
}
