
include Modeling

type KeywordInterval
let interval : KeywordInterval

type KeywordIntegral
let integral : KeywordIntegral

let minimize : <KeywordIntegral -> Real -> KeywordInterval -> 
                Real -> Real -> Equations>
let input : <Real -> Equations>

type VarSet = Set Signal
type VarMap = (Signal => Signal)
type ModelVars = (VarSet,VarSet,VarSet)
type MeshVars  = (VarMap,VarMap,VarMap)
type VarNameMap = (Signal => String)

def genMeshVarNameMap(meshVars:[MeshVars]) : VarNameMap = {
    def genName(vPrefix:String, mNbr:Int, vNbr:Int) : String = {
        vPrefix ++ "_" ++ int2string(mNbr) ++ "_" ++ int2string(vNbr)
    };
    def iterMeshVars(meshPointVars:MeshVars, mNbr:Int, nameMap:VarNameMap) : VarNameMap = {
        def genNames(varList:[(Signal,Signal)], vPrefix:String, vNbr:Int, nameMap:VarNameMap) : VarNameMap = {
            match varList with
            | v::vs -> {
                def (_,vv) = v;
                def n = genName(vPrefix, mNbr, vNbr);
                genNames(vs, vPrefix, vNbr+.1, (Map.add vv n nameMap))
                }
            | [] -> nameMap        
        };
	def (xMap, yMap, uMap) = meshPointVars;
        def xList = (Map.toList xMap);
        def nameMap_tmp1 = genNames(xList,"x",1,nameMap);
        def yList = (Map.toList yMap);
        def nameMap_tmp2 = genNames(yList,"y",1,nameMap_tmp1);
        def uList = (Map.toList uMap);
        genNames(uList,"u",1,nameMap_tmp2)
    };
    def iterMeshPoints(meshPointList:[MeshVars], mNbr:Int, nameMap:VarNameMap) : VarNameMap = {
        match meshPointList with
        | mv::mvs -> iterMeshPoints(mvs, mNbr+.1, iterMeshVars(mv, mNbr, nameMap)) 
        | [] -> nameMap        
    };
    iterMeshPoints(meshVars, 1, Map.empty)
}

def pprintPythonCasadiDecls(varNameMap:VarNameMap) : String = {
    def pprintVar(name:String) : String = {
        name ++ " = " ++ "C.SX(\"" ++ name ++ "\")"
    };
    def iterVars(varList:[(Signal,String)], acc:String) : String = {
        match varList with
        | v::vs -> {
            def (_,name) = v; 
            iterVars(vs, (acc ++ pprintVar(name) ++ "\n"))
        }
        | [] -> acc
    };
    def varNameList = (Map.toList varNameMap);	
    iterVars(varNameList,"")
}

def pprintPythonCasadiExpr(expr:Expr, varNameMap:VarNameMap) : String = {
    def printExpr(expr:Expr) : String = {
    match expr with 
    | e1 + e2 -> "(" ++ printExpr(e1) ++ " + " ++ printExpr(e2) ++ ")"
    | e1 - e2 -> "(" ++ printExpr(e1) ++ " - " ++ printExpr(e2) ++ ")"
    | e1 * e2 -> printExpr(e1) ++ " * " ++ printExpr(e2) 
    | e1 / e2 -> printExpr(e1) ++ " / " ++ printExpr(e2) 
    | -e ->     "(-" ++ printExpr(e) ++ ")" 
    | e1^e2 -> "(" ++ printExpr(e1) ++ ")" ++ " ^ " ++ "(" ++ printExpr(e2) ++ ")"
    | ~der e ->   "der(" ++ printExpr(e) ++ ")"
    | ~sin e ->   "sin(" ++ printExpr(e) ++ ")"
    | ~cos e ->   "cos(" ++ printExpr(e) ++ ")"
    | ~tan e ->   "tan(" ++ printExpr(e) ++ ")"
    | ~asin e ->  "asin(" ++ printExpr(e) ++ ")"
    | ~acos e ->  "acos(" ++ printExpr(e) ++ ")"
    | ~atan e ->  "atan(" ++ printExpr(e) ++ ")"
    | ~sinh e ->  "sinh(" ++ printExpr(e) ++ ")"
    | ~cosh e ->  "cosh(" ++ printExpr(e) ++ ")"
    | ~tanh e ->  "tanh(" ++ printExpr(e) ++ ")"
    | ~sqrt e ->  "sqrt(" ++ printExpr(e) ++ ")"
    | ~exp e ->   "exp(" ++ printExpr(e) ++ ")"
    | ~log e ->   "log(" ++ printExpr(e) ++ ")"
    | ~log10 e -> "log10(" ++ printExpr(e) ++ ")"
    | ~time -> "time"
    | sym:<Real> -> (Map.find expr varNameMap)
    | val r:Real -> real2string(r)
    };
    printExpr(expr)
}

def pprintPythonCasadiConstrs(equations:Equations, varNameMap:VarNameMap) : String = {
    def printEquations(equations:Equations, constrs:String) : String = {
	match equations with
        | eq1 ; eq2 -> printEquations(eq1, constrs) ++ printEquations(eq2,constrs)
        | left = right -> "constr += (" ++ pprintPythonCasadiExpr(left,varNameMap) ++ ") - (" ++ pprintPythonCasadiExpr(right, varNameMap) ++ ")\n"
        | _ -> ""
    };
    "constr = []\n" ++ printEquations(equations, "")
}

def pprintPythonCasadiCost(cost:Expr, varNameMap:VarNameMap) : String = {
    "cost = " ++ pprintPythonCasadiExpr(cost, varNameMap) ++ "\n"
}

def genInitMap(model:Equations) : VarMap = {
    def gen(m:Expr,acc:VarMap) : VarMap = {
        match m with
        | ~init (x=v) -> Map.add x v acc 
        | e1 e2 -> gen(e2,gen(e1,acc))
        | _ -> acc
    };
    gen(model,Map.empty)
}

def generateMeshVars(daeVars:ModelVars,n_e:Int) : [MeshVars] = {
    def genvar(varlst:[Signal],acc:VarMap) : VarMap = {
        match varlst with
        | v::vs -> {
             def m:Signal; 
             genvar(vs,Map.add v m acc)
          }
        | [] -> acc
    };
    def gen(vars:VarSet) : VarMap = genvar(Set.toList vars,Map.empty);
    def (x,y,u) = daeVars;
    def genmesh(n:Int) : [MeshVars] = {
        if n ==. 0 then [] 
        else (gen(x),gen(y),gen(u))::genmesh(n-.1) 
    };            
    genmesh(n_e)
}

def genNLPCost(cost:Expr, h:Real, meshVars:[MeshVars]) : Expr = {
    def substituteVars(exp:Expr, meshVars:MeshVars) : Expr ={
        def (xMap,yMap,uMap) = meshVars;
        match exp with
        | sym:Signal if Map.mem exp xMap -> Map.find exp xMap
        | sym:Signal if Map.mem exp yMap -> Map.find exp yMap
        | sym:Signal if Map.mem exp uMap -> Map.find exp uMap
        | e1 e2 -> {
            def e1b = substituteVars(e1, meshVars);
            def e2b = substituteVars(e2, meshVars);
            e1b e2b
          }
        | e -> e 
    };
    def genCostFunction(meshVarList:[MeshVars], cNLP:Expr) : Expr = {
        match meshVarList with
        | mv::mvs -> genCostFunction(mvs, cNLP + substituteVars(cost, mv)*h)
        | [] -> cNLP
    };
    genCostFunction(meshVars, val 0.0)
}

def genNLPConstraint(model:Equations, x0:VarMap, h:Real, meshVars:[MeshVars]) :
    Equations = {
    def substituteVars(model:Expr, prevX:VarMap, meshVars:MeshVars) : Expr = {
        def (xMap,yMap,uMap) = meshVars;
        match model with
        | ~der x -> ((Map.find x xMap) - (Map.find x prevX))/h
        | sym:Signal if Map.mem model xMap -> Map.find model xMap
        | sym:Signal if Map.mem model yMap -> Map.find model yMap
        | sym:Signal if Map.mem model uMap -> Map.find model uMap
        | e1 e2 -> {
            def e1b = substituteVars(e1, prevX, meshVars);
            def e2b = substituteVars(e2, prevX, meshVars);
            e1b e2b
          }
        | e -> e 
    };
    def genMeshPointConstraints(prevX:VarMap, meshVarList:[MeshVars], 
                                acc:Equations) : Equations = {
       match meshVarList with
       | mv::mvs -> {
           def (xMap,_,_) = mv;
           def meshPointConstr = substituteVars(model, prevX, mv);
           genMeshPointConstraints(xMap, mvs, acc ; meshPointConstr)
         }
       | [] -> acc
    };
    genMeshPointConstraints(x0, meshVars, NoEqn)
}




//Extract all types of variabels from a model. The return tuple
//is (x,y,u), where x is the state derivatives, y the algebraic variables
//and u the  input (control) signals
def extractVariables(model:Equations) : ModelVars = {
    def trav(e:Expr,acc:ModelVars) : ModelVars = {
        match (e,acc) with
        | (~der (sym:Signal),(X,Y,U)) -> 
             (match e with |~der x -> 
                if Set.mem x U then (X,Y,U) 
                else (Set.add x X,Set.remove x Y,U))
        | (~input (sym:Signal),(X,Y,U)) -> 
             (match e with |~input u -> 
               (Set.remove u X,Set.remove u Y,Set.add u U))
        | (sym:Signal,(X,Y,U)) -> 
             if (Set.mem e X) || (Set.mem e U) then (X,Y,U)
             else (X,Set.add e Y,U)
        | (e1 e2,_) -> trav e2 (trav e1 acc) 
        | _ -> acc
    };
    trav(model,(Set.empty,Set.empty,Set.empty))
}
  

//Traverse the model and extract the optimixation problem. In the 
//return tuple, the first parameter is the cost function, the
//second parameter t_0 and the third parameter t_f
def getOptProblem(model:Equations) : (Expr,Real,Real) = {
    def trav(e:Equations,rest:[Expr]) : (Expr,Real,Real) = {
        match (e,rest) with
        | (~minimize ~integral L ~interval (val start:Real) (val stop:Real),_) 
            -> (L,start,stop)
        | (e1;e2,_) -> trav(e1,e2::rest)
        | (_,e::es) -> trav(e,es)
        | (_,[]) -> error "No optimization problem found"
    };
    trav(model,[])
}




