
include Modeling

type KeywordInterval
let interval : <KeywordInterval>

type KeywordIntegral
let integral : <KeywordIntegral>

let minimize : <KeywordIntegral -> Real -> KeywordInterval -> 
                Real -> Real -> Eqs>
let input : <Real -> Eqs>

type VarSet = Set Signal
type VarMap = (Signal => Signal)
type ModelVars = (VarSet,VarSet,VarSet)
type MeshVars  = (VarMap,VarMap,VarMap)


def genInitMap(model:Equations) : VarMap = {
    def gen(m:Expr,acc:VarMap) : VarMap = {
        match m with
        | ~init x v -> Map.add x v acc 
        | e1 e2 -> gen(e2,gen(e1,acc))
        | _ -> acc
    };
    gen(model,Map.empty)
}



def generateMeshVars(daeVars:ModelVars,n_e:Int) : [MeshVars] = {
    def genvar(varlst:[Signal],acc:VarMap) : VarMap = {
        match varlst with
        | v::vs -> {
             def m:Signal; 
             genvar(vs,Map.add v m acc)
          }
        | [] -> acc
    };
    def gen(vars:VarSet) : VarMap = genvar(Set.toList vars,Map.empty);
    def (x,y,u) = daeVars;
    def genmesh(n:Int) : [MeshVars] = {
        if n ==. 0 then [] 
        else (gen(x),gen(y),gen(u))::genmesh(n-.1) 
    };            
    genmesh(n_e)
}
/*
def genNLPCost(cost:Expr, h:Real, meshVars:[MeshVars]) : Expr = {
    def substituteVars(exp:Expr, meshVars:MeshVars) : Expr ={
        def (xMap,yMap,uMap) = meshVars;
        match exp with
        | sym:Signal if Map.mem exp xMap -> Map.find exp xMap
        | sym:Signal if Map.mem exp yMap -> Map.find exp yMap
        | sym:Signal if Map.mem exp uMap -> Map.find exp uMap
        | e1 e2 -> {
            def e1b = substituteVars(e1, meshVars);
            def e2b = substituteVars(e2, meshVars);
            e1b e2b
          }
        | e -> e 
    };
    def genCostFunction(meshVarList:[MeshVars], cNLP:Expr) : Expr = {
        match meshVarList with
        | mv::mvs -> genCostFunction(mvs, cNLP + substituteVars(cost, mv)*h)
        | [] -> cNLP
    };
    genCostFunction(meshVars, 0.0)
}
*/

def genNLPConstraint(model:Equations, x0:VarMap, h:Real, meshVars:[MeshVars]) :
    Equations = {
    def substituteVars(model:Expr, prevX:VarMap, meshVars:MeshVars) : Expr = {
        def (xMap,yMap,uMap) = meshVars;
        match model with
        | ~der x -> ((Map.find x xMap) - (Map.find x prevX))/h
        | sym:Signal if Map.mem model xMap -> Map.find model xMap
        | sym:Signal if Map.mem model yMap -> Map.find model yMap
        | sym:Signal if Map.mem model uMap -> Map.find model uMap
        | e1 e2 -> {
            def e1b = substituteVars(e1, prevX, meshVars);
            def e2b = substituteVars(e2, prevX, meshVars);
            e1b e2b
          }
        | e -> e 
    };
    def genMeshPointConstraints(prevX:VarMap, meshVarList:[MeshVars], 
                                acc:Equations) : Equations = {
       match meshVarList with
       | mv::mvs -> {
           def (xMap,_,_) = mv;
           def meshPointConstr = substituteVars(model, prevX, mv);
           genMeshPointConstraints(xMap, mvs, acc ; meshPointConstr)
         }
       | [] -> acc
    };
    genMeshPointConstraints(x0, meshVars, NoEq)
}




//Extract all types of variabels from a model. The return tuple
//is (x,y,u), where x is the state derivatives, y the algebraic variables
//and u the  input (control) signals
def extractVariables(model:Equations) : ModelVars = {
    def trav(e:Expr,acc:ModelVars) : ModelVars = {
        match (e,acc) with
        | (~der (sym:Signal),(X,Y,U)) -> 
             (match e with |~der x -> 
                if Set.mem x U then (X,Y,U) 
                else (Set.add x X,Set.remove x Y,U))
        | (~input (sym:Signal),(X,Y,U)) -> 
             (match e with |~input u -> 
               (Set.remove u X,Set.remove u Y,Set.add u U))
        | (sym:Signal,(X,Y,U)) -> 
             if (Set.mem e X) || (Set.mem e U) then (X,Y,U)
             else (X,Set.add e Y,U)
        | (e1 e2,_) -> trav e2 (trav e1 acc) 
        | _ -> acc
    };
    trav(model,(Set.empty,Set.empty,Set.empty))
}
  

//Traverse the model and extract the optimixation problem. In the 
//return tuple, the first parameter is the cost function, the
//second parameter t_0 and the third parameter t_f
def getOptProblem(model:Equations) : (Expr,Real,Real) = {
    def trav(e:Equations,rest:[Expr]) : (Expr,Real,Real) = {
        match (e,rest) with
        | (~minimize ~integral L ~interval (val start:Real) (val stop:Real),_) 
            -> (L,start,stop)
        | (e1;e2,_) -> trav(e1,e2::rest)
        | (_,e::es) -> trav(e,es)
        | (_,[]) -> error "No optimization problem found"
    };
    trav(model,[])
}




