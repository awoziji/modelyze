/*
* Modular arm part library!
*/

include physical
include modelyzeEOO

def ArmLink(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // A single arm link mounted parallel to the ground
  // Modelled with a torque balance around the center of mass
  
  // Joint parameters
  def Lm = L/2.0; 	// Distance to center of mass from flangeA
  def m = L*0.4; 	// 2 kg per meter arm
  def I = m*L*L/12.0;	// Moment of inertia @ com
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB  + fxA*Lm*sin(thA) - fyA*Lm*cos(thA) + fxB*(L-Lm)*sin(thA) - fyB*(L-Lm)*cos(thA);
  m*xm'' = fxA - fxB;
  m*ym'' = fyA - fyB;
}

def VerticalArmLink(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // An arm link mounted vertically so that the gravity affects
  // the arm in the y-direction
  
  // Joint parameters
  def Lm = L/2.0; 	// distance to center of mass
  def m = L*0.4; 	// 2 kg per meter arm
  def I = m*L*L/12.0;	// Moment of inertia @ com
  
  def g = 9.81;
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB  + fxA*Lm*sin(thA) - fyA*Lm*cos(thA) + fxB*(L-Lm)*sin(thA) - fyB*(L-Lm)*cos(thA);
  m*xm'' = fxA - fxB;
  m*ym''=  fyA - fyB - g*m;
}

def ConstantTorqueJoint(M : <Real>, df : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // PARAMETERS
  def m = 0.6;	// Mass of the entire Joint
  def JA = 0.006; // Moment of Inertia around flangeA
  def JB = 0.006; // Moment of Inertia around flangeB
  
  // Forces and positions
  def fxA, fyA, fxB, fyB : Force;
  def TA, TB : Torque;
  def xA, yA, xB, yB : Position;
  def thA, thB : Angle;
  def dth : Angle;
  
  MultiRefBranch([fxA,fyA,TA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-TB],[xB,yB,thB],flangeB);
  
  // Equations:
  xA = xB;
  yA = yB;
  dth = thB - thA;
  
  m*xA'' = fxA - fxB;
  m*yA'' = fyA - fyB;
  JA*thA'' = -M + TA + df*dth';
  JB*thB'' = M - TB - df*dth';
}

def DCmotorJoint(u : Signal, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  //DC-motor parameters
  def K = 0.0229; def R = 1.83; def L = 0.192e-3; def n = 238.0;
  // Mechanical parameters
  def m = 0.6; // Mass of the entire joint
  def JA = 0.006; // Moment of inertia around flangeA
  def Jmotor = 9e-7 + 0.05e-7; // Rotor + encoder inertia
  def JB = Jmotor * n * n + 0.249e-7 + 0.006; // Moment of inertia around flangeB
  def df = 0.1;	// Friction
  
  // Forces and positions
  def fxA, fyA, fxB, fyB : Force;
  def TA, TB : Torque;
  def xA, yA, xB, yB : Position;
  def thA, thB : Angle;
  def dth : Angle;
  def i,M : Real;
  
  MultiRefBranch([fxA,fyA,TA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-TB],[xB,yB,thB],flangeB);
  
  // Equations:
  xA = xB;
  yA = yB;
  dth = thB - thA;
  
  m*xA'' = fxA - fxB;
  m*yA'' = fyA - fyB;
  
  u - R*i - K*n*dth' = 0.0;
  M = K*n*i;
  
  JA*thA'' = -M + TA + df*dth';
  JB*thB'' = M - TB - df*dth';
}

def SpringJoint(K : Real, d : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  dx = 0.0;
  dy = 0.0;
  Mth = -K*dth - d*dth';
  
  
}

def ArmFixed(flange : Mechanical2D) = {
  def fx, fy : Force;
  def M : Torque;
  def x,y : Position;
  def th : Angle;

  MultiRefBranch([fx,fy,M],[x,y,th],flange);
  x = 0.0; y = 0.0; th = 0.0;  
}

def ArmFixedY(flange : Mechanical2D) = {
  def fx, fy : Force;
  def M : Torque;
  def x,y : Position;
  def th : Angle;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flange);
  y = 0.0;
}

def PositionSensor(flangeP : Mechanical2D, sx : Signal, sy : Signal, sth : Signal) = {
  def x,y : Position;
  def th : Angle;
  def fx,fy : Force;
  def M : Torque;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flangeP);
  fx = 0.0; fy = 0.0; M = 0.0;
  
  sx = x;
  sy = y;
  sth = th;
}

def SpeedSensor(flangeP : Mechanical2D, sx : Signal, sy : Signal, sth : Signal) = {
  def x,y : Position;
  def th : Angle;
  def fx,fy : Force;
  def M : Torque;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flangeP);
  fx = 0.0; fy = 0.0; M = 0.0;
  
  sx = x';
  sy = y';
  sth = th';
}

def AccSensor(flangeP : Mechanical2D, sx : Signal, sy : Signal, sth : Signal) = {
  def x,y : Position;
  def th : Angle;
  def fx,fy : Force;
  def M : Torque;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flangeP);
  fx = 0.0; fy = 0.0; M = 0.0;
  
  sx = x'';
  sy = y'';
  sth = th'';
}

def RotSensor(flangeP : Mechanical2D, sth : Signal) = {
  def sx,sy : Signal;
  PositionSensor(flangeP,sx,sy,sth);
}

def RateSensor(flangeP : Mechanical2D, sth : Signal) = {
  def sx,sy : Signal;
  SpeedSensor(flangeP,sx,sy,sth);
}

def PIDcontroller(P : Real, I : Real, D : Real, ref : Signal, meas : Signal, out : Signal) = {
  
  def err, Ierr : Real;

  err = (ref - meas);  
  Ierr' = err;
  out = P*err + I*Ierr - D*meas';
  
}

def OutputFeedbackController(ref : Signal, meas : Signal, uout : Signal) = {
  def ufb, uff : Signal;
  30.65 * meas' + 377.4 * meas = ufb' + 16.26 * ufb;
  41.93 * ref' + 377.4 * ref = uff' + 16.26 * uff;
  uout = uff - ufb;
}

type ArmElement = <?> -> <?> -> Equations

def SerializeArms(is : Int, imax : Int, flangeA : Mechanical2D, flangeB : Mechanical2D, elem : ArmElement) -> Equations = {
  def recursiveArms(ic : Int , imax : Int, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
    def sth : Signal;
    
    if (ic == imax) then {
      elem(flangeA,flangeB);
      RotSensor(flangeB,sth);
      probe("th_" ++ int2string(ic)) = sth;
      
    } else {
      def flangeMid : Mechanical2D;
      
      elem(flangeA,flangeMid);
      recursiveArms(ic+1,imax,flangeMid,flangeB);
      RotSensor(flangeMid,sth);
      probe("th_" ++ int2string(ic)) = sth;
      
    };

  };
  recursiveArms(is,imax,flangeA,flangeB);
}

def SerializeArms(imax : Int, flangeA : Mechanical2D, flangeB : Mechanical2D, elem : ArmElement) -> Equations = {
  SerializeArms(1, imax, flangeA, flangeB, elem);
}

/* 
 ------------------------------- OLD VERSIONS ----------------------------------------
 ------------------------------------==-----------------------------------------------
*/
def ConstantTorqueJointOld(M : <Real>, df : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // PARAMETERS 
  def I = 0.0;
  
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  // Equations:
  dx = 0.0;
  dy = 0.0;
  I*dth'' = -M - df*dth' - Mth;
}

def DCmotorJointOld(u : Signal, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // PARAMETERS 
  def K = 0.0229*238.0; def R = 1.83; def I = 0.0; def df = 0.1;
  def i : Real;
  
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  // Equations
  dx = 0.0;
  dy = 0.0;
  u - R*i + K*dth' = 0.0;
  I*dth'' =  - K*i - df*dth' - Mth;
  
}

def ArmLinkOld(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // A single arm link mounted parallel to the ground
  
  // Joint parameters
  def Lm = L/2.0; 	// distance to center of mass
  def m = L*2.0; 	// 2 kg per meter arm
  def I = m*L*L/3.0;	// Moment of inertia @ endpoint
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB - yA''*Lm*cos(thA) + xA''*Lm*sin(thA) + fxB*L*sin(thA) - fyB*L*cos(thA);
  fxA = m*xm'' + fxB;
  fyA = m*ym'' + fyB;
}

def VerticalArmLinkOld(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // An arm link mounted vertically so that the gravity affects
  // the arm in the y-direction
  
  // Joint parameters
  def Lm = L/2.0; 	// distance to center of mass
  def m = L*2.0; 	// 2 kg per meter arm
  def I = m*L*L/3.0;	// Moment of inertia @ flangeA
  
  def g = 9.81;
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB - yA''*Lm*cos(thA) + xA''*Lm*sin(thA) + fxB*L*sin(thA) - fyB*L*cos(thA) - g*m*Lm*cos(thA);
  fxA = m*xm'' + fxB;
  fyA = m*ym'' + fyB + g*m;
}