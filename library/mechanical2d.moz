/*
* 2D - mechanical parts library
* 
* Author: Viktor Kozma
*/

include physical
include ModelyzeHEOO

/*********************** FRICTION MODELS ***********************/

type FrictionElement = <?> -> <?> -> Equations

def ExponentialFriction(Tf : <Real>, w : <Real>, c1 : <Real>, c2 : <Real>, c3 : <Real>) = {
  // Nonlinear continuously differentiable friction model
  Tf = sign(w)*c1*(1.0 - exp(-c2*abs(w))) + c3*w;
}

def LinearFriction(Tf : Signal, w : Signal, d : <Real>) = {
  // Linear friction
  Tf = d*w;
}

def QuadraticFriction(Tf : Signal, w : Signal, c1 : <Real>, c2 : <Real>) = {
  // Quadratic friction (note: be careful about going to fast with this representation)
  Tf = c1*w + sign(w)*c2*w*w;
}

def ColoumbFriction(Tf : Signal, w : Signal, c1 : <Real>, c2 : <Real>, c3 : <Real>) = {
  // Ghetto implementation of the coloumb friction
  Tf = c1 + c2*w + sign(w)*c3*w*w;
}


/*********************** ARM LINK ***********************/

// Switch name?
def ArmLink(L : Real, Lm : Real, I : Real, m : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // A single arm link mounted parallel to the ground
  // Modelled with a torque balance around the center of mass
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB  + fxA*Lm*sin(thA) - fyA*Lm*cos(thA) + fxB*(L-Lm)*sin(thA) - fyB*(L-Lm)*cos(thA);
  m*xm'' = fxA - fxB;
  m*ym'' = fyA - fyB;
}
//Overloaded function for easier use
def ArmLink(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // Some default parameters
  def Lm = L/2.0; 	// Distance to center of mass from flangeA
  def m = L*0.4; 	// 0.4 kg per meter arm
  def I = m*L*L/12.0;	// Moment of inertia @ com
  ArmLink(L,Lm,I,m,flangeA,flangeB);
}

/*********************** VERTICAL ARM LINK ***********************/

def VerticalArmLinkT(L : Real, Lm : Real, I : Real, m : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // An arm link mounted vertically so that the gravity affects
  // the arm in the y-direction
  
  def g = 9.81;
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB  + fxA*Lm*sin(thA) - fyA*Lm*cos(thA) + fxB*(L-Lm)*sin(thA) - fyB*(L-Lm)*cos(thA);
  m*xm'' = fxA - fxB;
  m*ym''=  fyA - fyB - g*m;
}
def VerticalArmLink(L : Real, flangeA: Mechanical2D, flangeB : Mechanical2D) -> Equations = {  
  // Joint parameters
  def Lm = L/2.0; 	// distance to center of mass
  def m = L*0.4; 	// 0.4 kg per meter arm
  def I = m*L*L/12.0;	// Moment of inertia @ com
  VerticalArmLinkT(L,Lm,I,m,flangeA,flangeB);
}

/*********************** MASSLESS CONSTANT TORQUE ***********************/

def MasslessConstantTorqueJoint(M : <Real>, df : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  // Equations:
  dx = 0.0;
  dy = 0.0;
  M = -df*dth' - Mth;
}

/*********************** CONSTANT TORQUE JOINT WITH INERTIA ***********************/

def ConstantTorqueJoint(M : <Real>, df : <Real>, JA : Real, JB : Real, m : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {

  // Forces and positions
  def fxA, fyA, fxB, fyB : Force;
  def TA, TB : Torque;
  def xA, yA, xB, yB : Position;
  def thA, thB : Angle;
  def dth : Angle;
  
  MultiRefBranch([fxA,fyA,TA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-TB],[xB,yB,thB],flangeB);
  
  // Equations:
  xA = xB;
  yA = yB;
  dth = thB - thA;
  
  m*xA'' = fxA - fxB;
  m*yA'' = fyA - fyB;
  JA*thA'' = -M + TA + df*dth';
  JB*thB'' = M - TB - df*dth';
}
def ConstantTorqueJoint(M : <Real>, df : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  def m = 0.6;	// Mass of the entire Joint
  def JA = 0.006; // Moment of Inertia around flangeA
  def JB = 0.006; // Moment of Inertia around flangeB
  ConstantTorqueJoint(M,df,JA,JB,m,flangeA,flangeB);
}

/*********************** MASSLESS DC MOTOR JOINT ***********************/

def MasslessDCmotorJoint(u : Signal, K : Real, R : Real, L : Real, n : Real, eta : Real, frictionFunction : FrictionElement, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // PARAMETERS 
  def i : Real;
  def Tf : <Real>;
  
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def T : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([fx,fy,T],[-dx,-dy,-dth],flangeA,flangeB);
  
  // Equations
  dx = 0.0;
  dy = 0.0;
  frictionFunction(Tf,dth');
  //probe("Tf") = Tf; // For testing
  u - R*i - L*i' - n*K*dth' = 0.0;
  T =  eta*n*K*i - Tf;
}
def MasslessDCmotorJoint(u : Signal, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // Default DC-motor joint, based on an DCX26L with n = 150
  def K = 0.0214; def R = 0.74+0.33; def L = 0.129e-3; def n = 150.0;
  def eta = 0.75; def df = 0.2;
  def frictionFunction(Tf : Signal, w : Signal) -> Equations = {
    LinearFriction(Tf,w,df);
  };
  MasslessDCmotorJoint(u,K,R,L,n,eta,frictionFunction,flangeA,flangeB);
}

/*********************** DC MOTOR JOINT WITH INERTIA ***********************/

def DCmotorJoint(u : Signal, K : Real, R : Real, L : Real, n : Real, eta : Real, JA : Real, JB : Real, m : Real, offset_A : Real, offset_B : Real, frictionFunction : FrictionElement, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  
  // Forces and positions
  def fxA, fyA, fxB, fyB : Force;
  def TA, TB : Torque;
  def xA, yA, xB, yB, x, y : Position;
  def thA, thB : Angle;
  def dth : Angle;
  def i,Tm : Real;
  def Tf : <Real>;
  
  MultiRefBranch([fxA,fyA,TA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-TB],[xB,yB,thB],flangeB);
  
  // Equations:
  x = xA + offset_A*cos(thA);
  xB = x + offset_B*cos(thB);
  y = yA + offset_A*sin(thA);
  yB = y + offset_B*sin(thB);
  
  //xB = xA;
  //yB = yA;
  dth = thB - thA;
  
  m*x'' = fxA - fxB;
  m*y'' = fyA - fyB;
  
  u - R*i - L*i' - K*n*dth' = 0.0;
  Tm = eta*K*n*i;
  frictionFunction(Tf,dth');
  JA*thA'' = -Tm + TA + Tf + fxA*offset_A*sin(thA) - fyA*offset_A*cos(thA);
  JB*thB'' = Tm - TB - Tf + fxB*offset_B*sin(thB) - fyB*offset_B*cos(thB);
}
def DCmotorJoint(u : Signal, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // Default DC motor joint with a DCX26L attached
  def K = 0.0214; def R = 0.74+0.33; def L = 0.129e-3; def n = 150.0;
  def eta = 0.75; def df = 0.1;
  def m = 1.4; // Mass of the entire joint
  def JA = 0.05; // Moment of inertia around flangeA
  def JB = 0.249e-7 + 0.05; // Moment of inertia around flangeB
  def frictionFunction(Tf : Signal, w : Signal) -> Equations = {
    LinearFriction(Tf,w,df);
  };
  DCmotorJoint(u,K,R,L,n,eta,JA,JB,m,0.0,0.0,frictionFunction,flangeA,flangeB);  
}

/*********************** FREE ROLLING JOINT ***********************/
def FreeJoint(JA : Real, JB : Real, m : Real, offset_A : Real, offset_B : Real, frictionFunction : FrictionElement, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  def fxA, fyA, fxB, fyB : Force;
  def TA, TB : Torque;
  def xA, yA, xB, yB, x, y : Position;
  def thA, thB : Angle;
  def dth : Angle;
  def Tf : <Real>;
  
  MultiRefBranch([fxA,fyA,TA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-TB],[xB,yB,thB],flangeB);
  
  // Equations:
  x = xA + offset_A*cos(thA);
  xB = x + offset_B*cos(thB);
  y = yA + offset_A*sin(thA);
  yB = y + offset_B*sin(thB);
  
  dth = thB - thA;
  
  m*x'' = fxA - fxB;
  m*y'' = fyA - fyB;
  
  frictionFunction(Tf,dth');
  
  JA*thA'' = TA + Tf + fxA*offset_A*sin(thA) - fyA*offset_A*cos(thA);
  JB*thB'' = - TB - Tf + fxB*offset_B*sin(thB) - fyB*offset_B*cos(thB);  
}


/*********************** SPRING JOINT ***********************/

def SpringJoint(K : Real, d : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  dx = 0.0;
  dy = 0.0;
  Mth = -K*dth - d*dth';  
}

/*********************** ARM FIXATION ***********************/

def ArmFixed(flange : Mechanical2D) -> Equations = {
  def fx, fy : Force;
  def M : Torque;
  def x,y : Position;
  def th : Angle;

  MultiRefBranch([fx,fy,M],[x,y,th],flange);
  x = 0.0; y = 0.0; th = 0.0;  
}

def ArmFixedY(flange : Mechanical2D) -> Equations = {
  def fx, fy : Force;
  def M : Torque;
  def x,y : Position;
  def th : Angle;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flange);
  y = 0.0;
}

/*********************** SENSORS ***********************/

def PositionSensor(flangeP : Mechanical2D, sx : Signal, sy : Signal, sth : Signal) -> Equations = {
  def x,y : Position;
  def th : Angle;
  def fx,fy : Force;
  def M : Torque;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flangeP);
  fx = 0.0; fy = 0.0; M = 0.0;
  
  sx = x;
  sy = y;
  sth = th;
}

def SpeedSensor(flangeP : Mechanical2D, sx : Signal, sy : Signal, sth : Signal) -> Equations = {
  def x,y : Position;
  def th : Angle;
  def fx,fy : Force;
  def M : Torque;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flangeP);
  fx = 0.0; fy = 0.0; M = 0.0;
  
  sx = x';
  sy = y';
  sth = th';
}

def AccSensor(flangeP : Mechanical2D, sx : Signal, sy : Signal, sth : Signal) -> Equations = {
  def x,y : Position;
  def th : Angle;
  def fx,fy : Force;
  def M : Torque;
  
  MultiRefBranch([fx,fy,M],[x,y,th],flangeP);
  fx = 0.0; fy = 0.0; M = 0.0;
  
  sx = x'';
  sy = y'';
  sth = th'';
}

def RotSensor(flangeP : Mechanical2D, sth : Signal) -> Equations = {
  def sx,sy : Signal;
  PositionSensor(flangeP,sx,sy,sth);
}

def RateSensor(flangeP : Mechanical2D, sth : Signal) -> Equations = {
  def sx,sy : Signal;
  SpeedSensor(flangeP,sx,sy,sth);
}

/*********************** Voltage Generators ***********************/

def SineVoltage(V : Real, f : Real, u : Signal) = {
  def time : Real;
  time' = 1.0;
  u = V * sin(2.0 * 3.1415 * f * time);  
}

def StepVoltage(V : Real, tstart : Real, trun : Real, u : Signal) = {
  def start, high, stop : Mode;
  def time : Real;
  time' = 1.0;
  
  hybridchart initmode (start) {
    mode start {
      u = 0.0*time;
      transition high when (time >= tstart) action nothing;
    };
    mode high {
      u = V + 0.0*time;
      transition stop when (time >= (tstart+trun)) action nothing;
    };
    mode stop {
      u = 0.0*time;
      transition start when (time < 0.0) action nothing;
    };
  };
  
}


/*********************** FEEDBACK CONTROLLERS ***********************/

def PIDcontroller(P : Real, I : Real, D : Real, ref : Signal, meas : Signal, out : Signal) -> Equations = {
  
  def err, Ierr : Real;

  err = (ref - meas);  
  Ierr' = err;
  out = P*err + I*Ierr - D*meas';
  
}

// Output feedback PD-controller
def PDcontroller(s1 : Real, s0 : Real, p1 : Real, p0 : Real, r0 : Real, ref : Signal, meas : Signal, uout : Signal) -> Equations = {
  def ufb, uff : Signal;
  ufb' + r0*ufb = s1*meas' + s0*meas;
  uff' + r0*uff = p1*ref' + s0*ref;  
  uout = uff - ufb;
}


/*********************** RECURSION ***********************/

type ArmElement = <?> -> <?> -> Equations

def SerializeArms(is : Int, imax : Int, flangeA : Mechanical2D, flangeB : Mechanical2D, elem : ArmElement) -> Equations = {
  def recursiveArms(ic : Int , imax : Int, flangeA : Mechanical2D, flangeB : Mechanical2D) -> Equations = {
    def sth : Signal;
    
    if (ic == imax) then {
      elem(flangeA,flangeB);
      RotSensor(flangeB,sth);
      probe("th_" ++ int2string(ic)) = sth;
      
    } else {
      def flangeMid : Mechanical2D;
      
      elem(flangeA,flangeMid);
      recursiveArms(ic+1,imax,flangeMid,flangeB);
      RotSensor(flangeMid,sth);
      probe("th_" ++ int2string(ic)) = sth;
      
    };

  };
  recursiveArms(is,imax,flangeA,flangeB);
}

def SerializeArms(imax : Int, flangeA : Mechanical2D, flangeB : Mechanical2D, elem : ArmElement) -> Equations = {
  SerializeArms(1, imax, flangeA, flangeB, elem);
}

/* 
 ------------------------------- OLD VERSIONS ----------------------------------------
 ------------------------------------==-----------------------------------------------
*/
def ConstantTorqueJointOld(M : <Real>, df : <Real>, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // PARAMETERS 
  def I = 0.0;
  
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  // Equations:
  dx = 0.0;
  dy = 0.0;
  I*dth'' = -M - df*dth' - Mth;
}
def DCmotorJointOld(u : Signal, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // PARAMETERS 
  def K = 0.0229*238.0; def R = 1.83; def I = 0.0; def df = 0.1;
  def i : Real;
  
  // X - Forces!
  def fx : Force;
  def dx : Position;
  // Y - Forces!
  def fy : Force;
  def dy : Position;
  // Torques and angles
  def Mth : Torque;
  def dth : Angle;
  
  // BRANCHES!!!!!!!!
  MultiBranch([-fx,-fy,-Mth],[dx,dy,dth],flangeA,flangeB);
  
  // Equations
  dx = 0.0;
  dy = 0.0;
  u - R*i + K*dth' = 0.0;
  I*dth'' =  - K*i - df*dth' - Mth;  
}

def ArmLinkOld(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // A single arm link mounted parallel to the ground
  
  // Joint parameters
  def Lm = L/2.0; 	// distance to center of mass
  def m = L*2.0; 	// 2 kg per meter arm
  def I = m*L*L/3.0;	// Moment of inertia @ endpoint
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB - yA''*Lm*cos(thA) + xA''*Lm*sin(thA) + fxB*L*sin(thA) - fyB*L*cos(thA);
  fxA = m*xm'' + fxB;
  fyA = m*ym'' + fyB;
}

def VerticalArmLinkOld(L : Real, flangeA : Mechanical2D, flangeB : Mechanical2D) = {
  // An arm link mounted vertically so that the gravity affects
  // the arm in the y-direction
  
  // Joint parameters
  def Lm = L/2.0; 	// distance to center of mass
  def m = L*2.0; 	// 2 kg per meter arm
  def I = m*L*L/3.0;	// Moment of inertia @ flangeA
  
  def g = 9.81;
  
  // X - Forces and positions
  def fxA, fxB : Force;
  def xA, xB : Position;
  // Y - Forces and positions
  def fyA, fyB : Force;
  def yA, yB : Position;
  // Torques and angles
  def MA, MB : Torque;
  def thA, thB : Angle;
  // Position of center of mass
  def xm,ym : Position;
  
  // BRANCHES!!!!!!!!
  MultiRefBranch([fxA,fyA,MA],[xA,yA,thA],flangeA);
  MultiRefBranch([-fxB,-fyB,-MB],[xB,yB,thB],flangeB);
  
  // Positions of the center of mass
  xm = xA + Lm*cos(thA);
  ym = yA + Lm*sin(thA);
  
  // Position equations
  thA = thB;
  xB = xA + L*cos(thA);
  yB = yA + L*sin(thA);
  
  // Force and torque equations
  I*thA'' = MA - MB - yA''*Lm*cos(thA) + xA''*Lm*sin(thA) + fxB*L*sin(thA) - fyB*L*cos(thA) - g*m*Lm*cos(thA);
  fxA = m*xm'' + fxB;
  fyA = m*ym'' + fyB + g*m;
}