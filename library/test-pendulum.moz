/*
Modeling Kernel Language (MKL) library 
Copyright (C) 2010-2011 David Broman

MKL library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MKL library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with MKL library.  If not, see <http://www.gnu.org/licenses/>.
*/

include MechsysBasics
include HybridSimulation
include ExportModelica


//Manual apply diff on last equation
def Pendulum(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y:Real;
    def startT = 33;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
    init T (startT);
     
    -T*x/l = m*x'';
    -T*y/l - m*g = m*y'';     
    (x^2 + y^2) = (l^2);

//    probe("startT") = startT;
    probe("x") = x;
    probe("y") = y;
    probe("dxx") = x'';
    probe("dyy") = y'';
//    probe("dy") = y';
//    probe("T") = T;
    probe("Lenght") = (sqrt(x*x+y*y));
}




//Apply differentiation according to pantelides, but removing old
def Pendulum2(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y,dx,dy:Real;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
     
    -T*x/l = m*dx';
    x' = dx;
    -T*y/l - m*g = m*dy';     
    y' = dy;    
    (x^2 + y^2) = (l^2);

    probe("x") = x;
    probe("y") = y;
    probe("Lenght") = (sqrt(x*x+y*y))
}


//Apply differentiation according to pantelides, but removing old
def Pendulum2P(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y,dx,dy:Real;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
     
    -T*x/l = m*dx';
    x'' = dx';
    -T*y/l - m*g = m*dy';     
    y'' = dy';    
    (x^2 + y^2)'' = (l^2)'';

    probe("x") = x;
    probe("y") = y;
    probe("Lenght") = (sqrt(x*x+y*y))
}



//Apply differentiation according to pantelides, but removing old
def PendulumP(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y,dx,dy:Real;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
     
    -T*x/l = m*dx';
    x'' = dx';
    -T*y/l - m*g = m*dy';     
    y'' = dy';    
    (x^2 + y^2)'' = (l^2)'';

    probe("x") = x;
    probe("y") = y;
    probe("Lenght") = (sqrt(x*x+y*y))
}



//Manually Apply dummy derivateive
def PendulumD1(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y,dx,dy:Real;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
     
    -T*x/l = m*dx';
    x' = dx;
    -T*y/l - m*g = m*dy';     
    y' = dy;    
    x^2 + y^2 = l^2;
    x * dx + y * dy = 0;
    //x * x'' + x' * x' + y * y'' + y' * y' = 0;
    x * dx' + dx * dx + y * dy' + dy * dy = 0;

    probe("x") = x;
    probe("Lenght") = (sqrt(x*x+y*y))
}


//Manually Apply dummy derivateive
def PendulumD2(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y,dx,dy,ddx,ddy,dx2,ddx2:Real;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
     
    -T*x/l = m*dx';
    x' = dx;
    ddx = dx';
    -T*y/l - m*g = m*dy';     
    y' = dy;    
    ddy = dy';    
    x^2 + y^2 = l^2;
    x * dx2 + y * y' = 0;
    x * ddx2 + x' * x' + y * y'' + y' * y' = 0;

    probe("x") = x;
    probe("Lenght") = (sqrt(x*x+y*y));
}


//Manual apply diff on last equation
def PendulumD3(m:Real,l:Real,startAngle:Real) = {
    def g = 9.81;
    def T,x,y,dx,dy,ddy:Real;

    init x (l*sin(startAngle));
    init y (-l*cos(startAngle));
     
    -T*x/l = m*dx';
    x' = dx;
    -T*y/l - m*g = m*dy';     
    y' = dy;    
//    -T*x/l = m*x'';
//    -T*y/l - m*g = m*y'';     
    x^2 + y^2 = l^2;
    x * x' + y * dy = 0;
    x * x'' + x' * x' + y * ddy + dy * dy = 0;

    probe("x") = x;
    probe("y") = y;
    probe("Lenght") = (sqrt(x*x+y*y));
}

def MiniPendulum() = {
   def y0,y1,y2,y3,y4:Real;
   init y0 1.0;
//   init (y3') (-9.82);

   y0' - y2 = 0;
   y1' - y3 = 0;
   y2' + y4 * y0 = 0;
   y3' + y4 * y1 + 9.82 = 0;
   y2^2 + y3^2 - y4 * (y0^2 + y1^2) - y1 * 9.82 = 0;
   probe "y0" = y0;
}        
// http://www.jmodelica.org/assimulo_home/tutorial_imp.html
//    res_0 = yd[0]-y[2]
//    res_1 = yd[1]-y[3]
//    res_2 = yd[2]+y[4]*y[0]
//    res_3 = yd[3]+y[4]*y[1]+9.82
//    res_4 = y[2]**2+y[3]**2-y[4]*(y[0]**2+y[1]**2)-y[1]*9.82
//    t0  = 0.0 #Initial time
//    y0  = [1.0, 0.0, 0.0, 0.0, 0.0] #Initial states
//    yd0 = [0.0, 0.0, 0.0, -9.82, 0.0] #Initial state derivatives





let _ = 
  let angle = 10*3.14/180. in
  //simulate (Pendulum2 5.0 2.0 angle) 0.01 10.
  //printsim (PendulumD3 5.0 2.0 angle) 0.01 10
  //printLine (exportModelica "Pendulum" (Pendulum5 5.0 2.0 angle))
  printsim(MiniPendulum(), 0.01, 10)










