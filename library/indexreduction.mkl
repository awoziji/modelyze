/*
Modeling Kernel Language (MKL) library 
Copyright (C) 2010-2011 David Broman

MKL library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MKL library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with MKL library.  If not, see <http://www.gnu.org/licenses/>.
*/

// indexreduction.mkl
//
//

include Modeling
include Pantelides
include Differentiation

//Equation node that the augmented equation system will contain.
//This is used for keeping track of the mapping between ENodes and
//the original equations
type PEqNode
type EqNode = <PEqNode>
let  eqContainer:<PEqNode -> Equations -> Equations> 

type VarSet = Set Expr

//Functions for generating fresh equation and variable nodes
let makeVNode x:() -> VNode = let n:Signal in n 
let makeENode x:() -> ENode = let n:EqNode in n

// Generates an equation grapjh from an equation system. This
// function can be used together with pantelides algrithm, 
// implemented in pantelides.mkl
let makeEquationGraph eqs:Equations -> (EqsGraph,VarMap,Equations) =
  let travExpr exp:Expr -> accvar:VarSet -> accvarmap:VarMap -> 
               (VarSet,VarMap) =
    match exp with
    | ~der (sym:Signal) -> 
        let x = match exp with | ~der u -> u in
        (Set.add exp accvar,Map.add x exp accvarmap) 
    | sym:Signal -> (Set.add exp accvar,accvarmap) 
    | e1 e2 -> let (accvar1,accvarmap1) = travExpr e1 accvar accvarmap in
               travExpr e2 accvar1 accvarmap1 
    | _ -> (accvar,accvarmap) 
  in
  let travEq eq:Equations -> accgraph:EqsGraph -> accvarmap:VarMap -> 
             (EqsGraph,VarMap,<>) =
    match eq with
    | e1 = e2 -> 
        let eqnode:EqNode in
        let (varset,accvarmap2) = travExpr (e1 - e2) (Set.empty) accvarmap in
        let accgraph2 = Map.add eqnode (Set.toList varset) accgraph in
        let neweq = eqContainer eqnode eq in
        (accgraph2,accvarmap2,neweq)
    | e1 e2 -> 
        let (accgraph1,accvarmap1,e1b) = travEq e1 accgraph accvarmap in
        let (accgraph2,accvarmap2,e2b) = travEq e2 accgraph1 accvarmap1 in
        (accgraph2,accvarmap2,e1b e2b)
    | e -> (accgraph,accvarmap,e)
  in
    travEq eqs (Map.empty) (Map.empty)


// Do index reduction using Panatelides algorithm. The original
// equations are replaced with the differentiated ones. This
// approach has the inherent drifting problem. Please use
// the dummy derivative method (function indexReducationDummyDer) 
// for mathematically correct reduction. This function is just
// for testing purposes. Note also that this function
// will not terminate if the equation system is structurally singular.
let indexReducationPantelides eqs:Equations -> olddermap:DerivMap -> 
          (Equations,DerivMap) =
  
  let addDerEqs eqs:Expr -> eqmap:EqMap -> Expr =
    let wrapder n:EqNode -> exp:Expr -> Expr =
      if Map.mem n eqmap 
        then der (wrapder (Map.find n eqmap) exp)
        else exp
    in
      match eqs with
      | ~eqContainer n e1 e2 -> (wrapder n e1) = (wrapder n e2)
      | e1 e2 -> (addDerEqs e1 eqmap) (addDerEqs e2 eqmap)
      | e -> e
  in
    // Generate the equation graph and augmented equation system
    let (graph,varmap,augmentedEqs) = makeEquationGraph eqs in
    // Execute Pantelides algorithm
    let (_,eqmap) = pantelides graph varmap makeVNode makeENode in
    // Wrap equations to be differentiated into der expressions
    let eqs2 = addDerEqs augmentedEqs eqmap in
    // Differentiate 
    elaborateDerivatives eqs2 olddermap











