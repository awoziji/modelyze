/*
Modeling Kernel Language (MKL) library 
Copyright (C) 2010 David Broman

MKL library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MKL library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with MKL library.  If not, see <http://www.gnu.org/licenses/>.
*/

// indexreduction.mkl
//
//

include Modeling
include Pantelides

//Equation node that the augmented equation system will contain.
//This is used for keeping track of the mapping between ENodes and
//the original equations
type PEqNode
type EqNode = <PEqNode>
let  eqContainer:<PEqNode -> Eqs -> Eqs> 

type VarSet = Set Expr

let makeEquationGraph eqs:Equations -> (EqsGraph,VarMap,Equations) =
  let travExpr exp:Expr -> accvar:VarSet -> accvarmap:VarMap -> 
               (VarSet,VarMap) =
    match exp with
    | ~der (uk:Signal) -> 
        let x = match exp with | ~der u -> u in
        (Set.add exp accvar,Map.add x exp accvarmap) 
    | uk:Signal -> (Set.add exp accvar,accvarmap) 
    | e1 e2 -> let (accvar1,accvarmap1) = travExpr e1 accvar accvarmap in
               travExpr e2 accvar1 accvarmap1 
    | _ -> (accvar,accvarmap) 
  in
  let travEq eq:Equations -> accgraph:EqsGraph -> accvarmap:VarMap -> 
             (EqsGraph,VarMap,Equations) =
    match eq with
    | e1 = e2 -> 
        let eqnode:EqNode in
        let (varset,accvarmap2) = travExpr (e1 - e2) (Set.empty) accvarmap in
        let accgraph2 = Map.add eqnode (Set.toList varset) accgraph in
        let neweq = eqContainer eqnode eq in
        (accgraph2,accvarmap2,neweq)
    | e1 e2 -> 
        let (accgraph1,accvarmap1,e1b) = travEq e1 accgraph accvarmap in
        let (accgraph2,accvarmap2,e2b) = travEq e2 accgraph1 accvarmap1 in
        (accgraph2,accvarmap2,e1b e2b)
    | e -> (accgraph,accvarmap,e)
  in
    travEq eqs (Map.empty) (Map.empty)







