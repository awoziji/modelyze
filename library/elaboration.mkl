/*
Modeling Kernel Language (MKL) library 
Copyright (C) 2010 David Broman

MKL library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MKL library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with MKL library.  If not, see <http://www.gnu.org/licenses/>.
*/

include Modeling

type Expr = <>
type Node = <>
type Unknown = <>
type Branch = <>
type NodeMap = (Node => Unknown)
type NodeMapList = [(Node,Unknown)]
type BranchSet = (Set Branch)
type BranchList = [Branch]
type ExprMap = (Node => Expr)
type ExprList = [(Node, Expr)]
type ProbeMap =  (String => [Signal])
type InitValMap = (<Real> => (Real,Bool))
type UkSet = (Set <Real>)
type UkMap = (Signal => (Int,Bool))
type SubExprMap = (<> => Signal)
type SubExprList = [(<>,Signal)]
type DerivMap = (Signal => Signal)
type DerivList = [(Signal,Signal)]


let elaborateConnections isBranch:(<> -> Bool) -> 
                         isRefBranch:(<> -> Bool) ->
                         model:Equations -> 
                         Equations =
  let addNode node:Node -> nodemap:NodeMap -> NodeMap =
    if Map.mem node nodemap then nodemap
    else let u:<Real> in Map.add node u nodemap
  in

  let sumexpr branches:BranchSet -> ExprMap = 
    let worker branches:BranchList -> emap:ExprMap -> ExprMap =
      match branches with
      | (b i v p n)::bs when isBranch b ->  
          let emap1 = if Map.mem p emap 
                      then Map.add p ((Map.find p emap) + i) emap
                      else Map.add p i emap in
          let emap2 = if Map.mem n emap1 
                      then Map.add n ((Map.find n emap1) - i) emap1
                      else Map.add n (-i) emap1 in
          worker bs emap2
      | (b i v p)::bs when isRefBranch b -> 
          let emap1 = if Map.mem p emap 
                      then Map.add p ((Map.find p emap) + i) emap
                      else Map.add p i emap in
          worker bs emap1
      | [] -> emap
    in worker (Set.toList branches) (Map.empty)
  in

  let sumzero m:Equations -> branches:BranchSet -> Equations =
    let worker elist:ExprList -> Equations =
      match elist with
      | (_,e)::es -> e = 0.; worker es
      | [] -> m
    in worker (Map.toList (sumexpr branches))
  in

  let potentials model:Equations -> (Equations,BranchSet) =
    let worker m:Equations -> nodemap:NodeMap -> 
                branchset:BranchSet -> (<>,NodeMap,BranchSet) =
      match m with
      | b i v p n when isBranch b ->
        let nodemap2 = addNode n (addNode p nodemap) in
        let eq = (v = (Map.find p nodemap2) - 
                 (Map.find n nodemap2)) in
        (eq,nodemap2,Set.add m branchset)
      | b i v p when isRefBranch b ->
        let nodemap2 = addNode p nodemap in
        let eq = (v = (Map.find p nodemap2)) in
        (eq,nodemap2,Set.add m branchset)
      | e1 ; e2 -> 
         let (e1b,nodemap1,branchset1) = 
               worker e1 nodemap branchset in
         let (e2b,nodemap2,branchset2) = 
               worker e2 nodemap1 branchset1 in
         (e1b ; e2b, nodemap2, branchset2)
      | _ ->  (m,nodemap,branchset) 
    in 
      let (model,_,branchset) = 
        worker model (Map.empty) (Set.empty) 
      in (model,branchset)
  in 
     let (model2,branchset2) = potentials model in
     sumzero model2 branchset2

let addProbe s:String -> u:Signal -> ps:ProbeMap =
    if Map.mem s ps then Map.add s (u::(Map.find s ps)) ps
    else Map.add s [u] ps

let elaborateProbes model:Equations -> (Equations,ProbeMap) =
  let elab e:<> -> ps:ProbeMap -> (<>,ProbeMap) = 
    match e with
    | ~probe (val s:String) -> let u:Signal in (u,addProbe s u ps)
    | e1 e2 -> 
       let (e1b,ps1) = elab e1 ps in
        let (e2b,ps2) = elab e2 ps1 in
       (e1b e2b,ps2)
    | _ -> (e,ps)
  in elab model (Map.empty)



//Extract equations of form  der x = dx, as well as recording such
//equations where higher-order derivatives will be generated after
//differentiation.
let extractDerivatives eqs:Equations -> dmap:DerivMap -> (Equations,DerivMap) =
  let makeHOder x:Signal -> k:Int -> dmap:DerivMap -> DerivMap =
    if k >. 1 then 
      if Map.mem x dmap then makeHOder (Map.find x dmap) (k -. 1) dmap
      else   
        let dx:Signal in
        makeHOder dx (k -. 1) (Map.add x dx dmap)
    else dmap
  in
  let extractHOder expr:Expr -> k:Int -> dmap:DerivMap -> DerivMap =
    match expr with
    | ~der e -> extractHOder e (k +. 1) dmap
    | ~time -> dmap
    | uk:Signal -> makeHOder expr k dmap
    | e1 e2 -> extractHOder e2 k (extractHOder e1 k dmap)
    | _ -> dmap
  in
  match eqs with
  | e1 ; e2 ->     
      let (e1b,dmap1) = extractDerivatives e1 dmap in
      let (e2b,dmap2) = extractDerivatives e2 dmap1 in
      (match (e1b,e2b) with
       | (~NoEq,~NoEq) -> (NoEq,dmap2)
       | (~NoEq,_)     -> (e2b,dmap2)
       | (_,~NoEq)     -> (e1b,dmap2)
       | (_,_)         -> (e1b;e2b,dmap2))
  | ~der ~time = _ -> (eqs,extractHOder eqs 0 dmap)
  | ~der _ = ~time -> (eqs,extractHOder eqs 0 dmap)
  | _ = ~der ~time -> (eqs,extractHOder eqs 0 dmap)
  | ~time = ~der _ -> (eqs,extractHOder eqs 0 dmap)
  | ~der uk:Signal = uk:Signal ->
      (match eqs with | ~der x = dx -> (NoEq,Map.add x dx dmap))
  | uk:Signal = ~der uk:Signal ->
      (match eqs with | ~der x = dx -> (NoEq,Map.add x dx dmap))
  | _ -> (eqs,extractHOder eqs 0 dmap)

//Symbolically differentiate a model (higher-order).
//What is missing is built in functions and other functions using
//the chain rule.
let differentiateModel expr:Expr -> Expr =
  let eulerNumber = 2.71828182845904523536 in
  let sdiff expr:Signal -> Signal =
    match expr with
    | ~time -> val 1.
    | uk:Signal -> hoDer expr 1
    | ~hoDer x (val k:Int) -> hoDer x (k +. 1)
    | ~der e -> sdiff (sdiff e)
    | e1 + e2 -> sdiff e1 + sdiff e2 
    | e1 - e2 -> sdiff e1 - sdiff e2 
    | e1 * e2 -> sdiff e1 * e2 + e1 * sdiff e2
    | e1 / e2 -> (sdiff e1 * e2 - e1 * sdiff e2) / (e2 * e2)
    | ~sin e -> sdiff e * cos e
    | ~cos e -> sdiff e * -(sin e)
    | ~tan e -> sdiff e * 1./(cos e)^2.
    | ~asin e -> sdiff e * (1. / (sqrt (1. - e^2.)))
    | ~acos e -> sdiff e * -(1. / (sqrt (1. - e^2.)))
    | ~atan e -> sdiff e * (1. / (1. + e^2.))
    | ~sinh e -> sdiff e * cosh e
    | ~cosh e -> sdiff e * sinh e
    | ~tanh e -> sdiff e * (1. / (cosh e)^2.)
    | ~log e -> sdiff e / e
    | ~log10 e -> sdiff e * log10 eulerNumber / e 
    | ~sqrt e -> sdiff e / (2.*(sqrt e))
    | e1 ^ (val k:Real) -> (k * e1 ^ (k - 1.)) * sdiff e1
    | -e -> -(sdiff e)
    | val x:Real -> val 0.
    | _ -> error "Cannot differentiate model"
  in
  match expr with
  | ~der e -> sdiff e
  | e1 e2 -> (differentiateModel e1)  (differentiateModel e2) 
  | _ -> expr

//Remove higher-order derivatives and replace them with new unknowns
//representing chains of derivatives.
let removeHOderivatives expr:Expr -> dmap:DerivMap -> Expr =
  let getDeriv x:Signal -> k:Int -> Expr =
    if k >. 1 then getDeriv (Map.find x dmap) (k -. 1)
    else 
      if Map.mem x dmap then Map.find x dmap
      else der x
  in
  match expr with
  | ~hoDer x (val k:Int) -> getDeriv x k
  | e1 e2 -> (removeHOderivatives e1 dmap) (removeHOderivatives e2 dmap) 
  | _ -> expr

//Generate equations of form  der x = dx, which removes the need for
//higher-order derivatives.
let generateEquations eqs:Equations -> dlist:DerivList -> Equations =
  match dlist with
  | (x,dx)::xs -> der x = dx; (generateEquations eqs xs)
  | _::xs -> generateEquations eqs xs 
  | [] -> eqs

//Elaborate derivatives. Symbolic differentiation of expressions and
//conversion from higher-order derivatives into derivatives of first order.
//This is the main function for elaboration of derivatives.
let elaborateDerivatives model:Equations -> Equations =
  let (eqs,dmap) =  extractDerivatives model (Map.empty) in
  let eqs2 = differentiateModel eqs in
  let eqs3 = removeHOderivatives eqs2 dmap in
  generateEquations eqs3 (Map.toList dmap) 
  

let initValues eqs:Equations -> InitValMap =
  let get eqs:Equations -> acc:InitValMap -> InitValMap =
    match eqs with
    | e1 ; e2 -> get e2 (get e1 acc)
    | ~Init x (val v:Real) -> Map.add x (v,false) acc
    | ~InitGuess x (val v:Real) -> Map.add x (v,true) acc
    | _ -> acc
  in get eqs (Map.empty)
 
let unknowns eqs:Equations -> UkSet =
  let get e:<> -> acc:UkSet -> UkSet = 
     match e with
     | e1 e2 -> get e2 (get e1 acc)
     | ~time -> acc
     | uk:<Real> -> Set.add e acc
     | _ -> acc 
  in get eqs (Set.empty)

let noUnknowns eqs:Equations -> Int =
  Set.size (unknowns eqs)

let noEquations eqs:Equations -> Int =
  match eqs with
  | e1 ; e2 -> (noEquations e1) +. (noEquations e2)
  | e1 = e2 -> 1
  | _ -> 0
 
let realUnknowns eqs:Equations -> (Int,UkMap) =
  let get e:<> -> acc:(Int,UkMap) -> (Int,UkMap) = 
     match e with
     | e1 e2 -> get e2 (get e1 acc)
     | ~time -> acc
     | ~der x -> 
        (match x with 
         | uk:<Real> -> 
             let (k,ukmap) = acc in 
             if Map.mem e ukmap 
             then (k,Map.add e (fst (Map.find e ukmap),true) ukmap)
             else ((k+.1,Map.add e (k,true) ukmap))
         | _ -> error "Illegal diffrentiation of expression") 
     | uk:<Real> -> if Map.mem e (snd acc) then acc
                    else ((fst acc)+.1,Map.add e (fst acc,false) (snd acc))
     | e1 -> acc 
  in get eqs (0,(Map.empty))

let makeUkMap eqs:Equations -> UkMap =
    snd (realUnknowns eqs)



