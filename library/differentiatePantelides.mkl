
include Differentiation
include Pantelides


type EqNodeMap = (ENode => Equations)
type EqNodeList = [(ENode,Equations)]



//Extract all equations from a system of equations 
let extractEqNodeMap eqs:Equations -> EqNodeMap =
  let extract eqs:Equations -> acc:EqNodeMap -> EqNodeMap = 
    match eqs with
    | e1 ; e2 -> extract e2 (extract e1 acc)
    | e1 = e2 -> let n:ENode in Map.add n eqs acc
    | _ -> acc
  in
    extract eqs (Map.empty) 

//Make the variable map A according to equatui (13), page 218
//by Pantelides (1988)
let makeVarSet eqs:Expr -> acc:VarSet -> VarSet = 
  match eqs with
  | ~der x -> Set.add eqs acc
  | sym:Signal -> Set.add eqs acc
  | e1 e2 -> makeVarSet e2 (makeVarSet e1 acc)
  | _ -> acc

//Create the initial equation map B, according to eqaution (14), 
//page 218 by Pantelides (1988)
let makeEqMap eqs:EqNodeList -> acc:EqMap -> EqMap =
  match eqs with
  | (n,eq)::es -> makeEqMap es (Map.add n nonode acc) 
  | [] -> acc
  
//Create the graph
let makeGraph eqs:EqNodeList -> acc:EqsGraph -> EqsGraph =
  match eqs with
  | (n,e)::es -> 
     let varset = makeVarSet e (Set.empty) in
     let acc2 = Map.add n varset acc in
     makeGraph es acc2
  | [] -> acc 

//let makeNotOnlyDer vset:VarList -> acc:VarSet -> VarSet =
//  match vset with
//  | (~der x)::xs -> makeNotOnlyDer xs (Set.add x (Set.add (der x) acc))
//  | x::xs -> makeNotOnlyDer xs (Set.add x acc)
//  | [] -> acc

let differentiatePantelides eqs:Equations -> Equations =
  let eqsmap = extractEqNodeMap eqs in
  let eqslist = Map.toList eqsmap in
  //let A = makeNotOnlyDer (Set.toList (makeVarSet eqs (Set.empty))) (Set.empty) in
  let A = makeVarSet eqs (Set.empty) in
  let B = makeEqMap eqslist (Map.empty) in
  eqs








