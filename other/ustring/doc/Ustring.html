<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Ustring" rel="Chapter" href="Ustring.html"><link title="Module String's functions" rel="Section" href="#6_ModuleStringsfunctions">
<link title="Additional string functions" rel="Section" href="#6_Additionalstringfunctions">
<link title="Encoding" rel="Section" href="#6_Encoding">
<link title="Lexing" rel="Section" href="#6_Lexing">
<link title="Comparison and Standard Collections" rel="Section" href="#6_ComparisonandStandardCollections">
<title>Ustring</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="index.html">Up</a>
&nbsp;</div>
<center><h1>Module <a href="type_Ustring.html">Ustring</a></h1></center>
<br>
<pre><span class="keyword">module</span> Ustring: <code class="code">sig</code> <a href="Ustring.html">..</a> <code class="code">end</code></pre>Unicode string library - Ustring.
    Version 0.01
    This module implements Unicode variants of functions using strings 
    in the OCaml standard library, e.g., modules <code class="code">String</code> and <code class="code">Pervasives</code>. 
    There are also a number of additional functions available. Several
    basic operators (e.g., equality and string concatenation) are defined in
    sub module <a href="Ustring.Op.html"><code class="code">Ustring.Op</code></a>. It is recommended to open up this sub module
    but not <code class="code">Ustring</code> directly.
<p>

    This module currently supports ASCII, Latin-1, and UTF-8 encoding. If
    another encoding is used, an exception will be raised. In all functions
    below, a ustring <code class="code">s</code> is indexed from <code class="code">0</code> to <code class="code">(Ustring.length s)-1</code>.
<p>

    Copyright (C) 2010-2012 David Broman. All rights reserved. This file
    is distributed under the "New BSD License".<br>
<hr width="100%">
<pre><span class="keyword">type</span> <a name="TYPEuchar"></a><code class="type"></code>uchar = <code class="type">int</code> </pre>
<div class="info">
Unicode char type. It is a basic integer.<br>
</div>

<pre><span class="keyword">module</span> <a href="Ustring.Op.html">Op</a>: <code class="code">sig</code> <a href="Ustring.Op.html">..</a> <code class="code">end</code></pre><div class="info">
Sub module <a href="Ustring.Op.html"><code class="code">Ustring.Op</code></a> is containing Unicode versions of several functions
    available in the <code class="code">Pervasives</code> module, as well as operators and functions 
    for simple string creation and manipulation (for example string concatenation 
    operator <code class="code">^.</code>, ustring equality operator <code class="code">=.</code> and string creation <code class="code">us"string"</code>).
</div>
<pre><span class="keyword">type</span> <a name="TYPEt"></a><code class="type"></code>t = <code class="type"><a href="Ustring.Op.html#TYPEustring">Op.ustring</a></code> </pre>
<div class="info">
Alias for the type <code class="code">Op.ustring</code><br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEustring"></a><code class="type"></code>ustring = <code class="type"><a href="Ustring.Op.html#TYPEustring">Op.ustring</a></code> </pre>
<div class="info">
Alias for the type <code class="code">Op.ustring</code><br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEencoding"></a><code class="type"></code>encoding = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Ascii</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Standard ASCII (values 0-127)</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Latin1</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Latin-1 encoding. Supports most European languages.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Utf8</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >UTF-8 encoding. Full Unicode encoding, where each character
               is represented by 1-4 bytes.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Utf16le</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Not yet supported</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Utf16be</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Not yet supported</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Utf32le</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Not yet supported</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Utf32be</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Not yet supported</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Auto</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Not a specific encoding, but a method for how encoded data
                is interpreted. If the input data have a 
                byte order mark (BOM) in the beginning of the sequence, the
                encoding type stated in the BOM will be used. 
		If no BOM is available, ASCII will initially be assumed to be 
		the encoding type. Then, when a byte sequence appear that is 
		not ASCII (value 0-127), a choice is made for the remaining 
		encoding type: If the sequence represents a legal UTF-8 encoded 
		character, the rest of the input will be treated as UTF-8 
                encoded. 
		If it is not an UTF encoded character, Latin-1 will be assumed 
		for the rest of the data sequence. Any later illegal decoding 
		will then be reported as an error.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<br>
<a name="6_ModuleStringsfunctions"></a>
<h6>Module String's functions</h6><br>
<br>
The following section implements the Unicode version of the
    functions available in standard library module <code class="code">String</code>.<br>
<pre><span class="keyword">val</span> <a name="VALlength"></a>length : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> int</code></pre><div class="info">
<code class="code">Ustring.length s</code> returns the number of characters of <code class="code">s</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget"></a>get : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> int -> <a href="Ustring.html#TYPEuchar">uchar</a></code></pre><div class="info">
<code class="code">Ustring.get s n</code> returns character number <code class="code">n</code> in ustring <code class="code">s</code>.
    Raises <code class="code">Invalid_argument "Ustring.get"</code> if out of range.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset"></a>set : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> int -> <a href="Ustring.html#TYPEuchar">uchar</a> -> unit</code></pre><div class="info">
<code class="code">Ustring.set s n c</code> modifies ustring <code class="code">s</code> in place by replacing uchar at
    index <code class="code">n</code> by uchar <code class="code">c</code>. Raises <code class="code">Invalid_argument "Ustring.get"</code> if out of 
    range.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcreate"></a>create : <code class="type">int -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Function <code class="code">Ustring.create n</code> returns a new fresh ustring with length <code class="code">n</code>
    characters. Raises <code class="code">Invalid_argument "Ustring.create"</code> if <code class="code">n &lt; 0</code> or
    <code class="code">n &gt; Sys.max_array_length</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmake"></a>make : <code class="type">int -> <a href="Ustring.html#TYPEuchar">uchar</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Function <code class="code">Ustring.make n c</code> returns a new fresh ustring of length <code class="code">n</code>, filled
    with character <code class="code">c</code>. Raises <code class="code">Invalid_argument "Ustring.make"</code> if <code class="code">n &lt; 0</code> or
    <code class="code">n &gt; Sys.max_array_length</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopy"></a>copy : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns a fresh copy of the string, i.e., there will be no more 
    sharing<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsub"></a>sub : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> int -> int -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Function <code class="code">Ustring.sub s start len</code> returns a new ustring with length
    <code class="code">len</code>, consisting of a sub-string of <code class="code">s</code>, which starts at index
    position <code class="code">start</code> and has length <code class="code">len</code>. Raises exception
    <code class="code">Invalid_argument "Ustring.sub"</code> if <code class="code">start</code> and <code class="code">len</code> does not
    give a valid sub-string.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconcat"></a>concat : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a> list -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
<code class="code">Ustring.concat sep sl</code> returns a ustring where the list of ustrings
    <code class="code">sl</code> are concatenated, were separator string <code class="code">sep</code> is inserted between
    each list element. The function always return a new fresh string.
    If performance is critical, use function fast_concat<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrindex"></a>rindex : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEuchar">uchar</a> -> int</code></pre><div class="info">
<code class="code">Ustring.rindex s c</code> returns the index of the last occurrence of 
    character <code class="code">c</code> in ustring <code class="code">s</code>. Raises <code class="code">Not_found</code> if <code class="code">c</code> does not
    occur in <code class="code">s</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrindex_from"></a>rindex_from : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> int -> <a href="Ustring.html#TYPEuchar">uchar</a> -> int</code></pre><div class="info">
<code class="code">Ustring.rindex_from s i c</code> returns the index of the last occurrence of
    character <code class="code">c</code> in ustring <code class="code">s</code> before index position <code class="code">i+1</code>. Note that
    function calls <code class="code">Ustring.rindex s</code> and 
    <code class="code">Ustring.rindex_from s (Ustring.length s - 1) c</code> are equivalent. 
    Raises <code class="code">Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code>. Raises
    <code class="code">Invalid_argument "Ustring.rindex_from"</code> if <code class="code">i+1</code> is an illegal 
    index in ustring <code class="code">s</code>.<br>
</div>
<br>
<a name="6_Additionalstringfunctions"></a>
<h6>Additional string functions</h6><br>
<pre><span class="keyword">val</span> <a name="VALappend"></a>append : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Append/concatenation of two strings. This function is equivalent to 
    infix operator <code class="code">^..</code>. Please see module <a href="Ustring.Op.html"><code class="code">Ustring.Op</code></a> for more details about the 
    operator. Note that this function is always creating a new fresh string
    after append. For performance demanding application, function 
    <code class="code">fast_append</code> or operator <code class="code">^.</code> are recommended instead.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfast_append"></a>fast_append : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Fast append/concatenation of two strings. Compared to function <code class="code">append</code> and  
    standard string concatenation operator <code class="code">^</code>, function <code class="code">fast_append</code> do not 
    allocate new memory or create a new fresh string. Instead,
    the concatenation is internally stored as a tree, making
    the operation constant time. When the string is later used by some function
    in module <code class="code">Ustring</code>, the internal tree representation will be automatically
    collapsed to a plain string. Note that in contrary to <code class="code">append</code>, this
    function do not create a fresh new string directly. Hence, if the sub strings
    are shared and modified in place, this string will also be updated. To
    make sure that the result string is unique, call function <code class="code">copy</code>.
    This function is equivalent to infix operator <code class="code">^.</code> Please see module 
    <a href="Ustring.Op.html"><code class="code">Ustring.Op</code></a> for more details about the operator.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfast_concat"></a>fast_concat : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a> list -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Same as function <code class="code">concat</code> with the difference that it is not returning
    a fresh string. Function <code class="code">fast_concat</code> is instead using <code class="code">fast_append</code> 
    for string concatenation.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcount"></a>count : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEuchar">uchar</a> -> int</code></pre><div class="info">
<code class="code">Ustring.count s c</code> returns the number of occurrences of character <code class="code">c</code>
    in ustring <code class="code">s</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtrim_left"></a>trim_left : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns a new ustring where white space (e.g. space, newline and tab) 
    is removed from the beginning of the input ustring.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtrim_right"></a>trim_right : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns a new ustring where white space (e.g. space, newline and tab) 
    is removed from the end of the input ustring.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtrim"></a>trim : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns a new ustring where white space (e.g. space, newline and tab) 
    is removed from the beginning and end of the input ustring.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALempty"></a>empty : <code class="type">unit -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns an empty ustring<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunix2dos"></a>unix2dos : <code class="type">string -> string</code></pre><div class="info">
Function <code class="code">Ustring.unix2dos s</code> returns a string where newline characters in 
    string <code class="code">s</code> are converted to the DOS and Windows standard. The ustring 
    module handles all strings internally using line feed (LF) code 0x0A, which
    is standard in Unix-like systems (e.g., GNU/Linux, Mac OS X, and FreeBSD).
    All input functions (e.g., <code class="code">from_utf8()</code> or <code class="code">from_latin1()</code>) automatically
    converts to this format. Hence, when ustrings are encoded using e.g.
    LATIN-1 or UTF-8, they will only contain the LF charcter for new line.
    However, for example Windows, DOS, OS/2 and Symbian OS are using
    the sequence of Carriage return (CR) 0x0D and LF 0x0A. This function
    converts from unix-style to this format.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring2hex"></a>string2hex : <code class="type">string -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Function <code class="code">Ustring.string2hex s</code> returns a comma separated list of hex
    values for the bytes in string <code class="code">s</code>. For example, from input string <code class="code">"an_"</code>
    a ustring <code class="code">"61,6e,5f"</code> is returned.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconvert_escaped_chars"></a>convert_escaped_chars : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Converts escaped characters. Raises 
      <code class="code">Invalid_argument "convert_escaped_chars"</code> if the string contains 
    illegal escape sequences.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_file"></a>read_file : <code class="type">?encode_type:<a href="Ustring.html#TYPEencoding">encoding</a> -> string -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Function <code class="code">Ustring.read_file fn</code> returns a ustring of the whole contents 
    of a file with file name <code class="code">fn</code>. By default, the encoding type is <code class="code">Auto</code>
    (see type <code class="code">encoding</code> for details). The input can also be forced to be
    assumed to be another encoding type. For example, expression
    <code class="code">Ustring.read_file ~encode_type:Ustring.Utf8 fn</code> creates
    an ustring that will assume that the input file is encoded using UTF-8. 
    If there is a decoding error exception <code class="code">Decode_error enc pos</code> is raised.
    Argument <code class="code">enc</code> is the encoding type 
    and <code class="code">pos</code> is number of bytes read from the file when the decoding error
    occurred. Raises <code class="code">Sys_error</code> if there where problems opening or reading
    from the file.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_from_channel"></a>read_from_channel : <code class="type">?encode_type:<a href="Ustring.html#TYPEencoding">encoding</a> -><br>       Pervasives.in_channel -> int -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Function <code class="code">Ustring.read_from_channel ic</code> returns a function which 
    can read from the in_channel. The returned function has one argument stating
    the number of Unicode characters that should be read from the stream.
    It returns an ustring with the read characters. The length of the
    returned ustring is approximately the requested number of characters,
    i.e., the function can do a partial read. If the returned ustring has
    length zero, the end of the character stream has been reached. If there is 
    a decoding error exception <code class="code">Decode_error enc pos</code> is raised. Argument  
    <code class="code">enc</code> is the encoding type and <code class="code">pos</code> is number of bytes read from the 
    file when the decoding error occurred. Note that this function should
    only be called once to get the read function <code class="code">int -&gt; ustring</code> and no
    other function is allowed to read from this channel at the same time.<br>
</div>
<br>
<a name="6_Encoding"></a>
<h6>Encoding</h6><br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONDecode_error"></a>Decode_error <span class="keyword">of</span> <code class="type">(<a href="Ustring.html#TYPEencoding">encoding</a> * int)</code></pre>
<div class="info">
Exception raised when a decode error occurrs. First parameter represents
    the encoding method used when the error occurred and the second parameter
    is the position in the stream/string/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfrom_latin1"></a>from_latin1 : <code class="type">string -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Creates an ustring from a string that is
    assumed to be encoded with Latin-1.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfrom_latin1_char"></a>from_latin1_char : <code class="type">char -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Creates an ustring from a Latin-1 encoded char<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfrom_utf8"></a>from_utf8 : <code class="type">string -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Creates an ustring from a string that is assumed to be
    encoded using UTF-8. Raises exception <code class="code">Invalid_argument "Ustring.from_utf8"</code> 
    if the input string has not a valid UTF-8 encoding. The input string
    must not have a byte order mark (BOM).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfrom_uchars"></a>from_uchars : <code class="type"><a href="Ustring.html#TYPEuchar">uchar</a> array -> <a href="Ustring.html#TYPEustring">ustring</a></code></pre><div class="info">
Converts an array of uchars to an ustring. Raises exception 
    <code class="code">Invalid_argument "Ustring.from_uchars"</code> if uchar values are illegal 
    (must be in range 0x0-0x1FFFFF).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlatin1_to_uchar"></a>latin1_to_uchar : <code class="type">char -> <a href="Ustring.html#TYPEuchar">uchar</a></code></pre><div class="info">
Converts a Latin-1 encoded char to an uchar<br>
</div>
<pre><span class="keyword">val</span> <a name="VALto_latin1"></a>to_latin1 : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> string</code></pre><div class="info">
Creates a new string encoded using Latin-1. Raises 
    <code class="code">Invalid_argument "Ustring.to_latin1"</code> if the characters are not within 
    the ASCII and Latin-1 character set (values 0-255).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALto_utf8"></a>to_utf8 : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> string</code></pre><div class="info">
Returns an UTF-8 encoded string. An UTF-8 string consist of a sequence of
    bytes where each Unicode character is encoded into 1 to 4 bytes. ASCII 
    characters are always encoded into 1 byte.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALto_uchars"></a>to_uchars : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> <a href="Ustring.html#TYPEuchar">uchar</a> array</code></pre><div class="info">
Returns an array of uchars.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvalidate_utf8_string"></a>validate_utf8_string : <code class="type">string -> int -> int</code></pre><div class="info">
Expression <code class="code">Ustring.validate_utf8_string s n</code> checks if the first <code class="code">n</code> characters
    of string <code class="code">s</code> have valid UTF-8 encoding. If the input is valid, but not all data
    is available (e.g. at the end, only 2 bytes are available for a character 
    that needs 3 bytes), the number of characters that represent
    whole characters are return. Raises exception 
    <code class="code">Decode_error enc pos</code> if the string has not a valid
    UTF-8 encoding. Argument <code class="code">enc</code> is the encoding type and <code class="code">pos</code> is the position 
    in string <code class="code">s</code> of the decode error.<br>
</div>
<br>
<a name="6_Lexing"></a>
<h6>Lexing</h6><br>
<br>
The <code class="code">Ustring</code> module is especially designed for simple support of 
    Unicode lexing and parsing. The below functions are defined for this
    purpose.<br>
<pre><span class="keyword">val</span> <a name="VALlexing_from_channel"></a>lexing_from_channel : <code class="type">?encode_type:<a href="Ustring.html#TYPEencoding">encoding</a> -> Pervasives.in_channel -> Lexing.lexbuf</code></pre><div class="info">
Creates a new <code class="code">Lexing.lexbuf</code> on a given input channel. Expression
    <code class="code">Ustring.lexing_from_channel inchan</code> returns a lexer buffer that reads
    from input channel <code class="code">inchan</code>. By default, the encoding type is <code class="code">Auto</code>
    (see type <code class="code">encoding</code> for details). The input can also be forced to be
    assumed to be another encoding type. For example, expression
    <code class="code">Ustring.lexing_from_channel ~encode_type:Ustring.Utf8 inchan</code> creates
    a lexbuf that will assume that the input data is encoded using UTF-8. 
    The stream of characters that are returned to the lexical analyzer is
    always UTF-8, regardless of the input encoding. Hence, this function
    is a simple and safe way to do lexical analysis of arbitrary encoded
    text data. If there is an encoding error of the data read from
    <code class="code">inchan</code>, Raises exception <code class="code">Decode_error enc pos</code> if there is a decoding 
    error of the data read from  <code class="code">inchan</code>. Argument <code class="code">enc</code> is the encoding type 
    and <code class="code">pos</code> is number of bytes read from <code class="code">inchan</code> when the decoding error
    occurred.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlexing_from_ustring"></a>lexing_from_ustring : <code class="type"><a href="Ustring.html#TYPEustring">ustring</a> -> Lexing.lexbuf</code></pre><div class="info">
Creates a new <code class="code">Lexing.lexbuf</code> that reads from a ustring. The stream of 
    characters that are returned to the lexical analyzer is
    always UTF-8.<br>
</div>
<br>
<a name="6_ComparisonandStandardCollections"></a>
<h6>Comparison and Standard Collections</h6><br>
<pre><span class="keyword">val</span> <a name="VALequal"></a>equal : <code class="type"><a href="Ustring.html#TYPEt">t</a> -> <a href="Ustring.html#TYPEt">t</a> -> bool</code></pre><div class="info">
Safe structural equality comparison function for ustrings. 
    For easy usage, use the equivalent operator <code class="code">=.</code> which is defined in
    module <a href="Ustring.Op.html"><code class="code">Ustring.Op</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnot_equal"></a>not_equal : <code class="type"><a href="Ustring.html#TYPEt">t</a> -> <a href="Ustring.html#TYPEt">t</a> -> bool</code></pre><div class="info">
Safe structural inequality comparison function for ustrings. 
    For easy usage, use the equivalent operator <code class="code">&lt;&gt;.</code> which is defined in
    module <a href="Ustring.Op.html"><code class="code">Ustring.Op</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcompare"></a>compare : <code class="type"><a href="Ustring.html#TYPEt">t</a> -> <a href="Ustring.html#TYPEt">t</a> -> int</code></pre><div class="info">
Comparison function for ustrings. Uses the same specification as 
    <code class="code">Pervasives.compare</code>. Since both type <code class="code">t</code> and function <code class="code">compare</code> is 
    implemented, module <code class="code">UString</code> can be passed directly to functors such
    as <code class="code">Set.Make</code> and <code class="code">Map.Make</code>. For example, to create a map the uses
    ustrings as the key, use the following source code line:
<p>

    <code class="code">module USMap = Map.Make (Ustring)</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALhash"></a>hash : <code class="type"><a href="Ustring.html#TYPEt">t</a> -> int</code></pre><div class="info">
Implements a safe hash function for ustrings. Since type <code class="code">t</code> and 
    functions <code class="code">hash</code> and <code class="code">equal</code> are implemented, module <code class="code">UString</code> can
    be passed directly to functor Hashtbl.Make, making it simple to
    use ustrings as keys in a hash table. For example, to create a 
    hash table that uses ustrings as keys, use the following source
    code line:
<p>

    <code class="code">module USHash = Hashtbl.Make(Ustring)</code><br>
</div>
</body></html>